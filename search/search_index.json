{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Fixie Developer Portal Fixie is a platform for building applications using Large Language Models. With Fixie, you can write apps that communicate, in natural language, with one or more Agents that can access individual APIs or sources of data, such as GitHub, Google Calendar, or a database. You can access the Fixie web interface at app.fixie.ai . Using the Fixie SDK allows you to connect your own applications to the Fixie platform, either as a client, or by building custom agents that plug into the platform. To learn more about Fixie, check us out at https://fixie.ai . Getting started Verify you can access app.fixie.ai with your Google or GitHub email Install the fixie CLI with pip install fixieai and run fixie auth to ensure your are successfully authenticated Fork the examples repo Choose any of the example agents, cd into the directory, and run fixie agent deploy Test that agent by running fixie console -a username/agent_name and inputting a test query. You can also run fixie console and then @ your specific agent (e.g. @username/agent_name this is the query ) You can also talk to deployed agents directly at app.fixie.ai For local development and testing, you can also run your agent locally with fixie agent serve . This is easier for debugging what\u2019s happening when things go wrong. This will create a tunnel to your local machine. After running serve, open a new terminal window and talk to the agent just like in step 5. Example of query using SDK: import fixieai response = fixieai . query ( \"How many countries start with the letter R ?\" ) print ( response ) Agent Examples Agents are at the heart of the Fixie ecosystem, and we make it easy to build and contribute your own. To get started you can scaffold out a default agent by running: fixie init . For more examples check out Building Fixie Agents and our examples repo . Documentation Check out the links below for more information on how to get started using Fixie. Tutorials Fixie Architecture Overview Agent Quickstart Building Fixie Agents Agent Protocol Reference Fixie CLI Reference Python Client API Python Agent API Fixie GraphQL API Reference","title":"Introduction"},{"location":"#fixie-developer-portal","text":"Fixie is a platform for building applications using Large Language Models. With Fixie, you can write apps that communicate, in natural language, with one or more Agents that can access individual APIs or sources of data, such as GitHub, Google Calendar, or a database. You can access the Fixie web interface at app.fixie.ai . Using the Fixie SDK allows you to connect your own applications to the Fixie platform, either as a client, or by building custom agents that plug into the platform. To learn more about Fixie, check us out at https://fixie.ai .","title":"Fixie Developer Portal"},{"location":"#getting-started","text":"Verify you can access app.fixie.ai with your Google or GitHub email Install the fixie CLI with pip install fixieai and run fixie auth to ensure your are successfully authenticated Fork the examples repo Choose any of the example agents, cd into the directory, and run fixie agent deploy Test that agent by running fixie console -a username/agent_name and inputting a test query. You can also run fixie console and then @ your specific agent (e.g. @username/agent_name this is the query ) You can also talk to deployed agents directly at app.fixie.ai For local development and testing, you can also run your agent locally with fixie agent serve . This is easier for debugging what\u2019s happening when things go wrong. This will create a tunnel to your local machine. After running serve, open a new terminal window and talk to the agent just like in step 5. Example of query using SDK: import fixieai response = fixieai . query ( \"How many countries start with the letter R ?\" ) print ( response )","title":"Getting started"},{"location":"#agent-examples","text":"Agents are at the heart of the Fixie ecosystem, and we make it easy to build and contribute your own. To get started you can scaffold out a default agent by running: fixie init . For more examples check out Building Fixie Agents and our examples repo .","title":"Agent Examples"},{"location":"#documentation","text":"Check out the links below for more information on how to get started using Fixie.","title":"Documentation"},{"location":"#tutorials","text":"Fixie Architecture Overview Agent Quickstart Building Fixie Agents Agent Protocol","title":"Tutorials"},{"location":"#reference","text":"Fixie CLI Reference Python Client API Python Agent API Fixie GraphQL API Reference","title":"Reference"},{"location":"agent-protocol/","text":"Fixie Agent Protocol Fixie Agents can be implemented in any programming language. The Fixie Python Agent API provides a Python SDK that makes it easy to implement Agents in Python, however, it is possible to implement Fixie Agents in any programming language, as long as the Agent code conforms to the following protocol. A Fixie Agent is a program that accepts HTTP requests of two types: An HTTP GET request to the / endpoint, which returns a list of few-shot examples that the Agent supports. An HTTP POST request to the /FUNC endpoint, which returns the result of calling the function FUNC with the parameters specified in the request. Agents can support multiple functions. Few-shot examples Upon receiving an HTTP GET request to the / endpoint, the Agent must return a list of few-shot examples that the Agent supports. The few-shot examples are used to provide examples to the underlying Large Language Model, such as GPT-3, as well as to provide the Fixie Platform information on what kinds of queries this Agent can support. The few-shot examples are returned as a JSON object with the following format: { \"base_prompt\" : \"The base prompt for the few-shot examples.\" , \"few_shots\" : [ \"The first few-shot example.\" , \"The second few-shot example.\" , \"The third few-shot example.\" ] } Each few-shot excample consists of one or more lines, separating by a newline character ( \\n ). The first line of each example must be a sample query, which must start with the prefix Q: . The final line of the few-shot example must be the corresponding answer, which must start with the prefix A: . The few-shot example may contain any number of lines in between the query and answer, representing intermediate outputs from the Large Language Model, as well as responses to the LLM from external functions. Here is an example of a single few-shot example: Q : Generate a random number between 0 and 19. Ask Func [ genrand ] : 0 , 19 Func [ genrand ] says : 17 A : The random number is 17. In this example, the first line represents a sample query that the Agent can support. The second line is the LLM response to receiving this query, which in this case indicates that the Function genrand should be invoked with the input string 0, 19 . The third line is the expected response from the Function genrand , and the final line is the answer to the query. Using the Fixie Python SDK, the values of the base_prompt and few_shots fields are specified by setting the values of the BASE_PROMPT and FEW_SHOTS variables in the Agent code, respectively. Function invocation Upon receiving an HTTP POST request to the /FUNC endpoint, the Agent must return the result of calling the Agent function FUNC with the parameters specified in the body of the HTTP POST request. The body of the POST request will be in the following format: { \"message\" : { \"text\" : \"Argument to function call\" , } } The Agent should invoke the function FUNC , passing in the contents of the JSON object message as the argument to the function call. The result of the function call should be returned as the value of the result field in the response to the HTTP POST request. The response to the HTTP POST request should be a JSON object in the format: { \"message\" : { \"text\" : \"Response to function call\" , } } Using the Fixie Python SDK, implementing an Agent function is done using the @fixieai.CodeShotAgent.register_func decorator. The decorator takes a single argument, which is the function to be registered. The function must take a single argument, which contains the JSON message object from the HTTP POST request. The function should return a string, which will be the value of the text field in the response message returned by the Agent. See python-agent-api.md for more information on the Fixie Python Agent API, and agent-quickstart.md for a quickstart guide on how to implement Agents in Fixie.","title":"Agent Protocol"},{"location":"agent-protocol/#fixie-agent-protocol","text":"Fixie Agents can be implemented in any programming language. The Fixie Python Agent API provides a Python SDK that makes it easy to implement Agents in Python, however, it is possible to implement Fixie Agents in any programming language, as long as the Agent code conforms to the following protocol. A Fixie Agent is a program that accepts HTTP requests of two types: An HTTP GET request to the / endpoint, which returns a list of few-shot examples that the Agent supports. An HTTP POST request to the /FUNC endpoint, which returns the result of calling the function FUNC with the parameters specified in the request. Agents can support multiple functions.","title":"Fixie Agent Protocol"},{"location":"agent-protocol/#few-shot-examples","text":"Upon receiving an HTTP GET request to the / endpoint, the Agent must return a list of few-shot examples that the Agent supports. The few-shot examples are used to provide examples to the underlying Large Language Model, such as GPT-3, as well as to provide the Fixie Platform information on what kinds of queries this Agent can support. The few-shot examples are returned as a JSON object with the following format: { \"base_prompt\" : \"The base prompt for the few-shot examples.\" , \"few_shots\" : [ \"The first few-shot example.\" , \"The second few-shot example.\" , \"The third few-shot example.\" ] } Each few-shot excample consists of one or more lines, separating by a newline character ( \\n ). The first line of each example must be a sample query, which must start with the prefix Q: . The final line of the few-shot example must be the corresponding answer, which must start with the prefix A: . The few-shot example may contain any number of lines in between the query and answer, representing intermediate outputs from the Large Language Model, as well as responses to the LLM from external functions. Here is an example of a single few-shot example: Q : Generate a random number between 0 and 19. Ask Func [ genrand ] : 0 , 19 Func [ genrand ] says : 17 A : The random number is 17. In this example, the first line represents a sample query that the Agent can support. The second line is the LLM response to receiving this query, which in this case indicates that the Function genrand should be invoked with the input string 0, 19 . The third line is the expected response from the Function genrand , and the final line is the answer to the query. Using the Fixie Python SDK, the values of the base_prompt and few_shots fields are specified by setting the values of the BASE_PROMPT and FEW_SHOTS variables in the Agent code, respectively.","title":"Few-shot examples"},{"location":"agent-protocol/#function-invocation","text":"Upon receiving an HTTP POST request to the /FUNC endpoint, the Agent must return the result of calling the Agent function FUNC with the parameters specified in the body of the HTTP POST request. The body of the POST request will be in the following format: { \"message\" : { \"text\" : \"Argument to function call\" , } } The Agent should invoke the function FUNC , passing in the contents of the JSON object message as the argument to the function call. The result of the function call should be returned as the value of the result field in the response to the HTTP POST request. The response to the HTTP POST request should be a JSON object in the format: { \"message\" : { \"text\" : \"Response to function call\" , } } Using the Fixie Python SDK, implementing an Agent function is done using the @fixieai.CodeShotAgent.register_func decorator. The decorator takes a single argument, which is the function to be registered. The function must take a single argument, which contains the JSON message object from the HTTP POST request. The function should return a string, which will be the value of the text field in the response message returned by the Agent. See python-agent-api.md for more information on the Fixie Python Agent API, and agent-quickstart.md for a quickstart guide on how to implement Agents in Fixie.","title":"Function invocation"},{"location":"agent-quickstart/","text":"Fixie Agent Quickstart Fixie allows you to extend the capabilities of the Fixie Platform by building your own Agents , which are specialized software components that combine a set of few-shot examples with code to invoke external systems. We call this combination of few-shots coupled with code Code Shots (clever, eh?). You can implement Fixie Agents in any programming language, however, the Fixie SDK currently provides bindings only for Python. See the Agent Protocol for details on implementing your own Agent in a language other than Python. We'll be shipping bindings for other languages soon! Create a Fixie Agent The first step is to create a new Agent directory using the fixie init command: $ mkdir myagent $ cd myagent $ fixie init Handle [ myagent ] : Description [] : A simple test agent. Entry point [ main:agent ] : More info url [] : Public [ False ] : fixie init will prompt you to enter some information about your Agent. The Agent Handle is its unique identifier, and is used to identify the Agent in the Fixie Platform. The Description is an optional plain-text description of the Agent's abilities. The Entry point is the name of the Python module that contains the Agent code, which we will create in the next step below. The More info url is an optional URL that you can provide that provides more information about the Agent; this can point to any website. The Public flag indicates whether the Agent should be publicly visible in the Fixie Platform for other users. If you set this to True , then anyone can use your Agent in their own applications. Running fixie init will create the file agent.yaml in the current directory, containing metadata on the Agent. Write the Agent code Next, paste the following code into a file called main.py : import random import fixieai BASE_PROMPT = \"I am a simple agent that generates a random number between two given values.\" FEW_SHOTS = \"\"\" Q: Generate a random number between 0 and 19. Ask Func[genrand]: 0, 19 Func[genrand] says: 17 A: The random number is 17. Q: Generate a random value from 5 to 10, inclusive. Ask Func[genrand]: 5, 10 Func[genrand] says: 8 A: The random number is 8. \"\"\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS ) @agent . register_func () def genrand ( query : fixieai . Message ) -> str : low , high = query . text . replace ( \" \" , \"\" ) . split ( \",\" ) return str ( random . randint ( int ( low ), int ( high ))) The code consists of two main parts: BASE_PROMPT and FEW_SHOTS : These are the few-shot examples that define the Agent's purpose and behavior. The few-shots are used to providing examples to the underlying Large Language Model, such as GPT-3, as well as to provide the Fixie Platform information on what kinds of queries this Agent can support. Code snippets : These are the functions that are invoked by the Code Shots. The code snippets are registered with the agent using the register_func decorator. In the FEW_SHOTS string, the Func[genrand] keyword indicates that the function genrand should be invoked when the output of the underlying LLM starts with this string. The values following Ask Func[genrand]: are passed to the function as the query.text parameter. In this case, the function parses out the values and returns a random number between those two values. Test your Agent To test your Agent, you have two options: (1) Run it on your local machine using the fixie agent serve command, or (2) Deploy it to the Fixie platform using the fixie agent deploy command. Using fixie agent serve allows you to debug the agent as it runs locally, but is generally only advisable for initial development. $ fixie serve Opening tunnel to 0 .0.0.0:8181... Tunneling 0 .0.0.0:8181 via https://df03e6d61a9f11.lhr.life When running fixie agent serve , a tunnel is set up that allows the Agent, running on your local machine, to be accessed from the Fixie Platform. The URL of the tunnel is printed on the console. If you quit the fixie agent serve process (e.g., by pressing Ctrl-C), the tunnel is torn down and your Agent is no longer accessible. Now you can use fixie console to send a message to your Agent directly: $ fixie console Welcome to Fixie! Connected to: https://app.fixie.ai/sessions/stormy-luxuriant-ferryboat fixie \ud83e\udd8a\u276f @myagent Generate a random number between 10 and 50 @user: @mdw/myagent Generate a random number between 10 and 50 @myagent: Generate a random number between 10 and 50 @myagent: Ask Func: 10 , 50 @myagent: Func says: 48 @myagent: The random number is 48 . 1 \u276f The random number is 48 . In the fixie agent serve window, you should also see debugging output showing that your Agent code was invoked with a POST request to the /genrand endpoint. Deploy your Agent Agents can be deployed on any web server that supports Python, however, you can also deploy your Agent directly to the Fixie platform, which takes care of hosting the Agent functions in the cloud. For this, all you need to do is run fixie agent deploy : $ fixie agent deploy \u2705 Deploying... \u2705 Refreshing... This will take about a minute to run. Once deployed, you can use your Agent via the Fixie web UI or the fixie console tool. Implementing Agents without Python See Agent Protocol for details on how to implement an Agent directly in a language other than Python, as well as Agent API for details on the complete Fixie Agent API.","title":"Agent QuickStart"},{"location":"agent-quickstart/#fixie-agent-quickstart","text":"Fixie allows you to extend the capabilities of the Fixie Platform by building your own Agents , which are specialized software components that combine a set of few-shot examples with code to invoke external systems. We call this combination of few-shots coupled with code Code Shots (clever, eh?). You can implement Fixie Agents in any programming language, however, the Fixie SDK currently provides bindings only for Python. See the Agent Protocol for details on implementing your own Agent in a language other than Python. We'll be shipping bindings for other languages soon!","title":"Fixie Agent Quickstart"},{"location":"agent-quickstart/#create-a-fixie-agent","text":"The first step is to create a new Agent directory using the fixie init command: $ mkdir myagent $ cd myagent $ fixie init Handle [ myagent ] : Description [] : A simple test agent. Entry point [ main:agent ] : More info url [] : Public [ False ] : fixie init will prompt you to enter some information about your Agent. The Agent Handle is its unique identifier, and is used to identify the Agent in the Fixie Platform. The Description is an optional plain-text description of the Agent's abilities. The Entry point is the name of the Python module that contains the Agent code, which we will create in the next step below. The More info url is an optional URL that you can provide that provides more information about the Agent; this can point to any website. The Public flag indicates whether the Agent should be publicly visible in the Fixie Platform for other users. If you set this to True , then anyone can use your Agent in their own applications. Running fixie init will create the file agent.yaml in the current directory, containing metadata on the Agent.","title":"Create a Fixie Agent"},{"location":"agent-quickstart/#write-the-agent-code","text":"Next, paste the following code into a file called main.py : import random import fixieai BASE_PROMPT = \"I am a simple agent that generates a random number between two given values.\" FEW_SHOTS = \"\"\" Q: Generate a random number between 0 and 19. Ask Func[genrand]: 0, 19 Func[genrand] says: 17 A: The random number is 17. Q: Generate a random value from 5 to 10, inclusive. Ask Func[genrand]: 5, 10 Func[genrand] says: 8 A: The random number is 8. \"\"\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS ) @agent . register_func () def genrand ( query : fixieai . Message ) -> str : low , high = query . text . replace ( \" \" , \"\" ) . split ( \",\" ) return str ( random . randint ( int ( low ), int ( high ))) The code consists of two main parts: BASE_PROMPT and FEW_SHOTS : These are the few-shot examples that define the Agent's purpose and behavior. The few-shots are used to providing examples to the underlying Large Language Model, such as GPT-3, as well as to provide the Fixie Platform information on what kinds of queries this Agent can support. Code snippets : These are the functions that are invoked by the Code Shots. The code snippets are registered with the agent using the register_func decorator. In the FEW_SHOTS string, the Func[genrand] keyword indicates that the function genrand should be invoked when the output of the underlying LLM starts with this string. The values following Ask Func[genrand]: are passed to the function as the query.text parameter. In this case, the function parses out the values and returns a random number between those two values.","title":"Write the Agent code"},{"location":"agent-quickstart/#test-your-agent","text":"To test your Agent, you have two options: (1) Run it on your local machine using the fixie agent serve command, or (2) Deploy it to the Fixie platform using the fixie agent deploy command. Using fixie agent serve allows you to debug the agent as it runs locally, but is generally only advisable for initial development. $ fixie serve Opening tunnel to 0 .0.0.0:8181... Tunneling 0 .0.0.0:8181 via https://df03e6d61a9f11.lhr.life When running fixie agent serve , a tunnel is set up that allows the Agent, running on your local machine, to be accessed from the Fixie Platform. The URL of the tunnel is printed on the console. If you quit the fixie agent serve process (e.g., by pressing Ctrl-C), the tunnel is torn down and your Agent is no longer accessible. Now you can use fixie console to send a message to your Agent directly: $ fixie console Welcome to Fixie! Connected to: https://app.fixie.ai/sessions/stormy-luxuriant-ferryboat fixie \ud83e\udd8a\u276f @myagent Generate a random number between 10 and 50 @user: @mdw/myagent Generate a random number between 10 and 50 @myagent: Generate a random number between 10 and 50 @myagent: Ask Func: 10 , 50 @myagent: Func says: 48 @myagent: The random number is 48 . 1 \u276f The random number is 48 . In the fixie agent serve window, you should also see debugging output showing that your Agent code was invoked with a POST request to the /genrand endpoint.","title":"Test your Agent"},{"location":"agent-quickstart/#deploy-your-agent","text":"Agents can be deployed on any web server that supports Python, however, you can also deploy your Agent directly to the Fixie platform, which takes care of hosting the Agent functions in the cloud. For this, all you need to do is run fixie agent deploy : $ fixie agent deploy \u2705 Deploying... \u2705 Refreshing... This will take about a minute to run. Once deployed, you can use your Agent via the Fixie web UI or the fixie console tool.","title":"Deploy your Agent"},{"location":"agent-quickstart/#implementing-agents-without-python","text":"See Agent Protocol for details on how to implement an Agent directly in a language other than Python, as well as Agent API for details on the complete Fixie Agent API.","title":"Implementing Agents without Python"},{"location":"agents/","text":"Developing a Fixie Agent The Fixie platform allows you to build Agents in any language of your choice, by writing a service that conforms to the protocol described in Agent Protocol . For Python developers, we provide a Python library that makes it easy to implement Agents using the API described below. For a quick start on building your own Fixie Agent, check out the Quick Start guide. See Fixie Agent Python API for the full API reference. CodeShotAgent The base class for Agents in Fixie is [ CodeShotAgent ][fixieai.agents.code_shot. CodeShotAgent]. This class takes care of communicating with the Fixie platform via the Agent Protocol , and provides a simple API for registering functions that can be invoked by the few-shot examples used by the Agent. The structure of a CodeShotAgent is typically as follows: import fixieai BASE_PROMPT = \"Base prompt for the agent.\" FEW_SHOTS = \"\"\" Q: Example query for the Agent Ask Func[my_func]: query to the func Func[my_func] says: response to the query A: Response generated by the Agent Q: Second example query to the agent A: Second response generated by the Agent \"\"\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS ) @agent . register_func () def my_func ( query : fixieai . Message ) -> str : return \"Response to the query\" The BASE_PROMPT and FEW_SHOTS strings are used to provide examples to the underlying Large Language Model, such as GPT-3, as well as to provide the Fixie Platform information on what kinds of queries this Agent can support. The FEW_SHOTS provided to an Agent must be a string consisting of one or more stanzas , where each stanza consists of a question, one or more rounds of internal actions taken by the Agent, and a final answer. Stanzas must be separated from each other by a blank line. The query line in the stanza must start with Q: , and the answer line must start with A: . Internal actions taken by the Agent can be of one of two forms: Ask Func[<func_name>]: <query_text> : This indicates that the function <func_name> should be invoked when the output of the underlying LLM starts with this string. The string following Ask Func[<func_name>]: is passed to the function as the query.text parameter. Ask Agent[<agent_name>]: <query_text> : This indicates that the Agent <agent_name> should be invoked when the output of the underlying LLM starts with this string. The string following Ask Agent[<agent_name>]: is passed to the Agent as the query.text parameter. Agent Funcs A Func is a function, defined in Python, that can be invoked by the Agent. (Note that Funcs need not be implemented in Python; you can implement Agents in other languages, as long as they adhere to the Fixie Agent Protocol .) As described above, when the language model for an Agent emits the token Ask Func[<func_name>] , the function <func_name> will be invoked. The register_func decorator is used to register a function that can be invoked by the Agent. A function registered with the register_func decorator has the signature: @agent . register_func () def my_func ( query , user_storage = None , oauth_handler = None ): ... The query parameter is either a str a Message object. If the query parameter is a string, this parameter contains the text of the Agent query. If the query parameter is a Message object, this parameter contains the text of the Agent along with zero or more Embed objects, as described in the Embeds section below. The optional user_storage parameter provides the Func an interface to the Fixie User Storage service, as described below. The optional oauth_handler parameter provides the Func an interface to performing OAuth authentication with external services, as described in the OAuth section below. The function must return either a str or a Message object. Returning a string is equivalent to returning a Message object with the string as its text field, and no embeds . Built-in functions All Fixie agents have access to the following set of built-in functions that they can invoke. Ask Func[base_prompt] : Returns the base prompt for the agent. Ask Func[local_datetime] : Returns the current datetime in the user's local timezone. Ask Func[utc_datetime] : Returns the current datetime in UTC timezone. Ask Func[query_embed] : Runs the prompt in the query against the contents of the embed. Ask Func[query_corpus] : Runs the prompt in the query against the contents of the agent-defined corpus. Embeds Embeds allow arbitrary binary data to be associated with a query or response Message in Fixie, similar to email attachments. Embeds can be used to store images, video, text, or any other binary data. Embeds are represented by the Embed class. Agents can access the Embeds associated with a Message as follows: @agent . register_func () def my_func ( query : fixieai . Message ) -> str : for key , embed in query . embeds . items (): print ( f \"Embed key: { key } \" ) print ( f \"Embed content-type: { embed . content_type } \" ) embed_value_as_text = embed . text embed_value_as_bytes = embed . content An Agent function can also add an Embed to its response Message by adding it to the embeds dictionary of the Message object: @agent . register_func () def my_func ( query : fixieai . Message ) -> fixieai . Message : reply = fixieai . Message ( \"Response to the query\" ) reply . embeds [ \"my_embed\" ] = fixieai . Embed ( content_type = \"text/plain\" ) reply . embeds [ \"my_embed\" ] . text = \"Hello, world!\" User Storage Fixie Agents can store and retrieve arbitrary data associated with a user, using the UserStorage class. This class provides a simple interface to a persistent key/value storage service, with a separate key/value store for each Fixie user. This can be used to maintain state about a particular user that persists across Agent invocations. The UserStorage instance for a given query can be obtained by providing a user_storage parameter to an Agent function. The UserStorage object acts as a Python dict that stores state associated with an arbitrary string key. UserStorage values may consist of Python primitive types, such as str , int , float , bool , None , or bytes , as well as lists of these types, or a Dict mapping a str to one of these types. User Storage Example @agent . register_func () def my_func ( query : fixieai . Message , user_storage : fixieai . UserStorage ) -> str : user_storage [ \"my_key\" ] = \"my_value\" return user_storage [ \"my_key\" ] Agent OAuth Support Fixie Agents can authenticate to third-party services to perform actions on behalf of the user. This is done using OAuth 2.0, which is a standard protocol for authorization. OAuth 2.0 allows users to grant limited access to their accounts on one service, to another service, without having to share their password. Fixie provides a simple interface for Agents to perform OAuth authentication, using the OAuthParams class. Using this class, an Agent function can use the OAuthHandler class -- which is passed to the function as the oauth_handler parameter -- to obtain an access token for the user. OAuth Example import fixieai oauth_params = fixieai . OAuthParams () oauth_params . client_id = \"XXXXX.apps.googleusercontent.com\" , oauth_params . auth_uri = \"https://accounts.google.com/o/oauth2/auth\" oauth_params . token_uri = \"https://oauth2.googleapis.com/token\" oauth_params . client_secret = \"XXXXXXXXX\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS , oauth_params = oauth_params ) @agent . register_func def my_func ( query , oauth_handler : fixieai . OAuthHandler ): user_token = oauth_handler . user_token () if user_token is None : # Return the URL that the user should click on to authorize the Agent. return oauth_handler . get_authorization_url () # Do something with the user_token returned by the OAuth handler. client = gcalendar_client . GcalendarClient ( user_token ) # ...","title":"Fixie Agent API"},{"location":"agents/#developing-a-fixie-agent","text":"The Fixie platform allows you to build Agents in any language of your choice, by writing a service that conforms to the protocol described in Agent Protocol . For Python developers, we provide a Python library that makes it easy to implement Agents using the API described below. For a quick start on building your own Fixie Agent, check out the Quick Start guide. See Fixie Agent Python API for the full API reference.","title":"Developing a Fixie Agent"},{"location":"agents/#codeshotagent","text":"The base class for Agents in Fixie is [ CodeShotAgent ][fixieai.agents.code_shot. CodeShotAgent]. This class takes care of communicating with the Fixie platform via the Agent Protocol , and provides a simple API for registering functions that can be invoked by the few-shot examples used by the Agent. The structure of a CodeShotAgent is typically as follows: import fixieai BASE_PROMPT = \"Base prompt for the agent.\" FEW_SHOTS = \"\"\" Q: Example query for the Agent Ask Func[my_func]: query to the func Func[my_func] says: response to the query A: Response generated by the Agent Q: Second example query to the agent A: Second response generated by the Agent \"\"\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS ) @agent . register_func () def my_func ( query : fixieai . Message ) -> str : return \"Response to the query\" The BASE_PROMPT and FEW_SHOTS strings are used to provide examples to the underlying Large Language Model, such as GPT-3, as well as to provide the Fixie Platform information on what kinds of queries this Agent can support. The FEW_SHOTS provided to an Agent must be a string consisting of one or more stanzas , where each stanza consists of a question, one or more rounds of internal actions taken by the Agent, and a final answer. Stanzas must be separated from each other by a blank line. The query line in the stanza must start with Q: , and the answer line must start with A: . Internal actions taken by the Agent can be of one of two forms: Ask Func[<func_name>]: <query_text> : This indicates that the function <func_name> should be invoked when the output of the underlying LLM starts with this string. The string following Ask Func[<func_name>]: is passed to the function as the query.text parameter. Ask Agent[<agent_name>]: <query_text> : This indicates that the Agent <agent_name> should be invoked when the output of the underlying LLM starts with this string. The string following Ask Agent[<agent_name>]: is passed to the Agent as the query.text parameter.","title":"CodeShotAgent"},{"location":"agents/#agent-funcs","text":"A Func is a function, defined in Python, that can be invoked by the Agent. (Note that Funcs need not be implemented in Python; you can implement Agents in other languages, as long as they adhere to the Fixie Agent Protocol .) As described above, when the language model for an Agent emits the token Ask Func[<func_name>] , the function <func_name> will be invoked. The register_func decorator is used to register a function that can be invoked by the Agent. A function registered with the register_func decorator has the signature: @agent . register_func () def my_func ( query , user_storage = None , oauth_handler = None ): ... The query parameter is either a str a Message object. If the query parameter is a string, this parameter contains the text of the Agent query. If the query parameter is a Message object, this parameter contains the text of the Agent along with zero or more Embed objects, as described in the Embeds section below. The optional user_storage parameter provides the Func an interface to the Fixie User Storage service, as described below. The optional oauth_handler parameter provides the Func an interface to performing OAuth authentication with external services, as described in the OAuth section below. The function must return either a str or a Message object. Returning a string is equivalent to returning a Message object with the string as its text field, and no embeds .","title":"Agent Funcs"},{"location":"agents/#built-in-functions","text":"All Fixie agents have access to the following set of built-in functions that they can invoke. Ask Func[base_prompt] : Returns the base prompt for the agent. Ask Func[local_datetime] : Returns the current datetime in the user's local timezone. Ask Func[utc_datetime] : Returns the current datetime in UTC timezone. Ask Func[query_embed] : Runs the prompt in the query against the contents of the embed. Ask Func[query_corpus] : Runs the prompt in the query against the contents of the agent-defined corpus.","title":"Built-in functions"},{"location":"agents/#embeds","text":"Embeds allow arbitrary binary data to be associated with a query or response Message in Fixie, similar to email attachments. Embeds can be used to store images, video, text, or any other binary data. Embeds are represented by the Embed class. Agents can access the Embeds associated with a Message as follows: @agent . register_func () def my_func ( query : fixieai . Message ) -> str : for key , embed in query . embeds . items (): print ( f \"Embed key: { key } \" ) print ( f \"Embed content-type: { embed . content_type } \" ) embed_value_as_text = embed . text embed_value_as_bytes = embed . content An Agent function can also add an Embed to its response Message by adding it to the embeds dictionary of the Message object: @agent . register_func () def my_func ( query : fixieai . Message ) -> fixieai . Message : reply = fixieai . Message ( \"Response to the query\" ) reply . embeds [ \"my_embed\" ] = fixieai . Embed ( content_type = \"text/plain\" ) reply . embeds [ \"my_embed\" ] . text = \"Hello, world!\"","title":"Embeds"},{"location":"agents/#user-storage","text":"Fixie Agents can store and retrieve arbitrary data associated with a user, using the UserStorage class. This class provides a simple interface to a persistent key/value storage service, with a separate key/value store for each Fixie user. This can be used to maintain state about a particular user that persists across Agent invocations. The UserStorage instance for a given query can be obtained by providing a user_storage parameter to an Agent function. The UserStorage object acts as a Python dict that stores state associated with an arbitrary string key. UserStorage values may consist of Python primitive types, such as str , int , float , bool , None , or bytes , as well as lists of these types, or a Dict mapping a str to one of these types.","title":"User Storage"},{"location":"agents/#user-storage-example","text":"@agent . register_func () def my_func ( query : fixieai . Message , user_storage : fixieai . UserStorage ) -> str : user_storage [ \"my_key\" ] = \"my_value\" return user_storage [ \"my_key\" ]","title":"User Storage Example"},{"location":"agents/#agent-oauth-support","text":"Fixie Agents can authenticate to third-party services to perform actions on behalf of the user. This is done using OAuth 2.0, which is a standard protocol for authorization. OAuth 2.0 allows users to grant limited access to their accounts on one service, to another service, without having to share their password. Fixie provides a simple interface for Agents to perform OAuth authentication, using the OAuthParams class. Using this class, an Agent function can use the OAuthHandler class -- which is passed to the function as the oauth_handler parameter -- to obtain an access token for the user.","title":"Agent OAuth Support"},{"location":"agents/#oauth-example","text":"import fixieai oauth_params = fixieai . OAuthParams () oauth_params . client_id = \"XXXXX.apps.googleusercontent.com\" , oauth_params . auth_uri = \"https://accounts.google.com/o/oauth2/auth\" oauth_params . token_uri = \"https://oauth2.googleapis.com/token\" oauth_params . client_secret = \"XXXXXXXXX\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS , oauth_params = oauth_params ) @agent . register_func def my_func ( query , oauth_handler : fixieai . OAuthHandler ): user_token = oauth_handler . user_token () if user_token is None : # Return the URL that the user should click on to authorize the Agent. return oauth_handler . get_authorization_url () # Do something with the user_token returned by the OAuth handler. client = gcalendar_client . GcalendarClient ( user_token ) # ...","title":"OAuth Example"},{"location":"architecture/","text":"Fixie Architecture Overview This page provides a technical overview of the Fixie platform, specifically focusing on the programming model used to build applications with Fixie. System overview The diagram below is a high level sketch of the Fixie platform. The Fixie system consists of a cloud-hosted API (app.fixie.ai) which provides a GraphQL-based API endpoint to clients, and a set of Agents that each have a specific set of skills, such as accessing a remote API, pulling data from a database, summarizing text, and so forth. The core Fixie service runs on the cloud or on-prem in a customers environment. Agents can run anywhere: Hosted by Fixie, hosted by a customer, or hosted by third parties. Each Agent is its own independent microservice. Fixie's Agent registry maintains metadata about each agent, including its description, owner information, and the URL on which messages can be sent to the Agent. GraphQL API The Fixie GraphQL API allows clients to interact with the system in a number of ways: Query the set of Agents in the system, returning metadata about each Agent such as the name, owner, set of example queries that the Agent supports, etc. Register a new agent (described in the Creating an Agent section below). Create, list, and delete Sessions. A Session can be thought of as a chat session with the Fixie system, between the client and one or more Agents. Post a Message to a Session, which sends a new query to Fixie for processing by the system. Retrieve the Messages in a Session, including those Messages sent by Agents. Example query flow To illustrate the system working end-to-end, lets walk through what happens when a client issues a query, such as \"Schedule a 30-minute meeting with Zach sometime between now and next Tuesday\" . The red circled numbers on the diagram above refer to each of the steps below. The client issues the query by posting a message to a Session, via the GraphQL API (or, equivalently, via the web playground). The Session Runner dispatches the users query to the Fixie Agent. The Fixie Agent is the first Agent in the query sequence, and is responsible for taking the users query, breaking it into steps, and dispatching it out to one or more Agents for processing of those steps. Think of the Fixie Agent as a virtual machine that runs the program specified by the users query. The Session Runner is responsible for maintaining the running chat log of the session, and providing this context to the Fixie Agent. For example, if the following query were something vague, like \"When is it?\" , the Fixie Agent could disambiguate this to mean \"When is the meeting that you just scheduled?\" based on the session history provided by the Session Runner. For each step in the program, the Fixie Agent calls out to the Router Agent to determine which Agent(s) need to be invoked to run that step of the query. The Router Agent consults the Agent Registry, which contains metadata about each Agent, including the Agents name, owner, and (critically) the sample queries that the Agent can support. For example, the GitHub agent can support a wide range of queries about GitHub-related things, such as \"How many pull requests are open in fixie-ai/fixie?\" . When an Agent is registered with the system, it stores its sample queries in the registry, which the Router Agent uses to determine which queries should be routed to that Agent. The Router determines which Agent to send the query to by using a neural search that maps the users query into a high-dimensional embedding space, and compares it to the sample queries for each of the Agents in the system. The Router sends the users query to the Agent that most closely matches the sample queries for that Agent. The Agent (in this case, perhaps the Google Calendar Agent) gets the query and executes it. This is typically done by using a large language model such as GPT-3 to interpret the query and invoke one or more external systems to generate a response. In the case of the example query given above, this would entail querying the users own calendar for available time slots, querying Zachs calendar for available time slots, finding a suitable time that works for both parties, and then scheduling the meeting. Well describe this process in more detail in the Agent Execution section below. Finally, the response from the Agent is returned up the chain back to the Fixie Agent, which may decide to compose and send a final response to the user, or invoke other steps of the program involving other Agents. The response message is stored in the Session associated with this query, as well as returned to the client application. (The response path is not shown on the diagram for sake of simplicity.) Query message format Queries in Fixie consist of two parts: A plain-text Message along with zero or more Embeds. Concretely, a query message in Fixie is a JSON object that might contain: { \"text\" : \"Mask out the background in #1\" , \"embeds\" : { \"1\" : { \"content_type\" : \"image/png\" , \"uri\" : \"https://app.fixie.ai/attachment/21cfa1...\" , } } An Embed is very much like an email attachment: it is a binary object with an associated MIME type, such as image/png or text/plain , that is carried along with the query. Agents can access the Embeds associated with the query, and optionally create new Embeds that represent the result of some data processing or generation. As an example, the DALL-E and Stable Diffusion Agents both create Embeds for the images they generate. The Masker agent takes an image Embed and generates a binary mask representing portions of the image that contain a given object or material (e.g.,whatever is in the background of the image). Embeds are immutable once created. They are stored in a Fixie-managed cloud storage bucket, and are passed by reference (specifically, using a signed URL) along with the query. The text of the query can refer to an Embed using its key in the message. In the above example, the Embed key is 1 , and the query refers to it using #1 . Creating an Agent A Fixie Agent is just a program that accepts a query (text with optional embeds) in the format shown above, and returns a reply in the same format. An Agent can run anywhere on the Internet; Fixie only needs to know the URL to post the query message to over HTTP. The simplest possible Agent, implemented in Python, might look like this: from flask import Flask , request app = Flask ( __name__ ) @app . route ( \"/\" , methods = [ \"POST\" ]) def agent (): query = request . json [ \"text\" ] embeds = request . json [ \"embeds\" ] # Do something with the query... return { \"text\" : \"Hello, world!\" } That\u2019s it! Sending a POST request to the Agent\u2019s URL will return a reply \"Hello, world!\" . Of course, most Fixie Agents will want to use a large language model to process incoming queries and generate responses. There are two ways of doing this in Fixie. Fully custom Agents An Agent can essentially do anything it likes with the input query. The most common pattern here is to directly call a Large Language Model. on its own, e.g., via the OpenAI GPT-3 API. Fixie is agnostic as to how the Agent performs its query processing; it could use GPT-3, a fine-tuned variant like InstructGPT, or a fully custom model provided by the Agent developer or a third party. Libraries like LangChain are sometimes helpful in interfacing the LLM to external code. Instead of using an LLM directly, an Agent can also just be a simple wrapper around a third party AI-powered service that can perform tasks such as text summarization, text generation, search, etc. Building an Agent that wraps, for example, Jasper.ai , Instructive.ai, or Copy.ai is quite easy to do. The benefit of this approach is that those siloed products suddenly become interconnected and composable with the rest of the capabilities in the Fixie ecosystem. Code Shot Agents In addition to the roll your own approach with custom Agents, Fixie provides a novel programming model for building Agents that we call Code Shots . In Large Language Models, the term few shots refers to a set of examples that can be provided to the model that instructs it to perform a specific task. Code Shots are essentially few shots enhanced with embedded code. This is probably best understood through an example. The following Code Shots manifest creates an Agent that understands how to translate English queries into stock price lookups: import fixieai import requests BASE_PROMPT = \"I am an Agent that answers questions about stock prices.\" FEW_SHOTS = \"\"\"Q: What is the current price for SYMBOL? Ask Func[quote]: SYMBOL Func[quote] says: $123.45 A: The current price for SYMBOL is $123.45. Q: SYMBOL share price Ask Func[quote]: SYMBOL Func[quote] says: $34.52 A: The share price for SYMBOL is $34.52. Q: Price for SYMBOL Ask Func[quote]: SYMBOL Func[quote] says: $99.11 A: The share price for SYMBOL is $99.11 \"\"\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS ) API_KEY = \"...\" @agent . register_func () def quote ( query ): symbol = query . message . text url = f \"https://www.alphavantage.co/query?function=GLOBAL_QUOTE&apikey= { API_KEY } &symbol= { symbol } \" response = requests . get ( url ) raw_price = response . json ()[ \"Global Quote\" ][ \"05. price\" ] dot = raw_price . index ( \".\" ) return raw_price [: dot + 3 ] agent . serve ( \"stockquote\" ) This is the entire code for the stock quote Agent. The code manifest consists of a set of few-shot examples (example queries and responses), coupled with a little bit of Python code that knows how to invoke an external API to fetch a stock quote. With Code Shots, the Agents functionality is partitioned across two domains: the language processing (done centrally, by Fixie), and the low-level Func invocations (done within the Agent's own sandbox, either in the customers infrastructure or within an environment that is hosted by us). Because a Func does not need to perform any language processing, it is just a simple function! Let\u2019s walk through what happens when a query comes into a Code Shot Agent. The Agent gets a query like \"What is the stock price for GOOG?\" Fixie takes the users query, along with the few-shot examples in the Code Shots manifest, and passes them to a LLM for processing. Note that this language processing is being done centrally, by Fixie, meaning we can automatically select the best LLM and prompt to handle the query, as well as augment the prompt with relevant context and session history. 3. In this case, the output of the LLM will be something like Ask Func[quote]: GOOG . This is basically saying that Fixie needs to invoke this low-level Func to perform the next step of processing. Fixie invokes the Func by sending a REST call over HTTP to the Agents URL, and getting back the response. Fixie then feeds the Funcs response back into the LLM, again with the appropriate prompt and context, to continue processing the query. In this case, the LLM will generate a response like \"A: The share price for GOOG is $105.22\" . 5. The final reply is sent back to the client, or the Agent that issued the original query. There are a few key things to note about Code Shots. First, they make it really easy to build new Agents, since the only thing the developer needs to do is write a few English-language examples of what the Agent does, along with, possibly, one or more simple Funcs that hook into the query processing logic. Second, Funcs need not be private to individual Agents: We are building an entire library of Funcs that Agents can use, including Funcs that evaluate simple computational expressions, fetch data over HTTP, and so forth. Many Agents can be built without implementing any new Funcs, just by calling existing ones. Registering an Agent Fixie users can create and register their own Agents in the system either via the GraphQL API or through the web interface. The only thing needed to create an Agent is to give it a name, a short description of what it does, and a URL to which Agent queries should be sent. Authentication Fixie ensures that all requests flowing through the system are associated with an end user. A user can get a Fixie account by visiting the web UI (https://app.fixie.ai) and signing up using email, a Google account, or a GitHub account. To access the Fixie GraphQL API, the user can get an API key from their profile page on the site. The API key must be provided in an Authorization: Bearer header when making API calls. The API key itself is a JWT, signed by the Fixie service, that identifies the user associated with the query. When Fixie sends a request to an Agent, the request carries with it a JWT (again, signed by Fixie) that identifies the user and the chat session ID. The Agent can verify that an incoming query is in fact coming from Fixie by checking the signature of this JWT. When the Agent wishes to send a query to another Agent, or invoke one of the API endpoints provided by Fixie, it must provide this JWT to prove that the request is being made in the context of an actual user query. Usage limits Fixie imposes generous usage limits on individual users and Agents to prevent abuse. We currently have a per-user daily limit of 1000 queries. If this turns out not to be adequate we can raise the limit or allow users to purchase additional credits. Agents invoking Fixie APIs, such as the User Storage mechanism described below, also have a rate limit on those calls. Code Shot Agents that use Fixies language processing capabilities will additionally have a limit on the number of tokens they can pass through the Fixie-provided LLM API in a given time period. User Storage Agents often need to maintain state associated with a given user or chat session in which they are involved. While Agents could simply implement their own mechanism for this (e.g., writing data to a database or a cloud storage bucket), we provide a simple API in Fixie for this purpose. Fixies User Storage component is a simple key-value store, allowing Agents to store and retrieve binary blobs associated with an Agent-provided key. This is akin to cookies in a browser context, allowing Agents to stash away information that they might need to access later.","title":"Architecture"},{"location":"architecture/#fixie-architecture-overview","text":"This page provides a technical overview of the Fixie platform, specifically focusing on the programming model used to build applications with Fixie.","title":"Fixie Architecture Overview"},{"location":"architecture/#system-overview","text":"The diagram below is a high level sketch of the Fixie platform. The Fixie system consists of a cloud-hosted API (app.fixie.ai) which provides a GraphQL-based API endpoint to clients, and a set of Agents that each have a specific set of skills, such as accessing a remote API, pulling data from a database, summarizing text, and so forth. The core Fixie service runs on the cloud or on-prem in a customers environment. Agents can run anywhere: Hosted by Fixie, hosted by a customer, or hosted by third parties. Each Agent is its own independent microservice. Fixie's Agent registry maintains metadata about each agent, including its description, owner information, and the URL on which messages can be sent to the Agent.","title":"System overview"},{"location":"architecture/#graphql-api","text":"The Fixie GraphQL API allows clients to interact with the system in a number of ways: Query the set of Agents in the system, returning metadata about each Agent such as the name, owner, set of example queries that the Agent supports, etc. Register a new agent (described in the Creating an Agent section below). Create, list, and delete Sessions. A Session can be thought of as a chat session with the Fixie system, between the client and one or more Agents. Post a Message to a Session, which sends a new query to Fixie for processing by the system. Retrieve the Messages in a Session, including those Messages sent by Agents.","title":"GraphQL API"},{"location":"architecture/#example-query-flow","text":"To illustrate the system working end-to-end, lets walk through what happens when a client issues a query, such as \"Schedule a 30-minute meeting with Zach sometime between now and next Tuesday\" . The red circled numbers on the diagram above refer to each of the steps below. The client issues the query by posting a message to a Session, via the GraphQL API (or, equivalently, via the web playground). The Session Runner dispatches the users query to the Fixie Agent. The Fixie Agent is the first Agent in the query sequence, and is responsible for taking the users query, breaking it into steps, and dispatching it out to one or more Agents for processing of those steps. Think of the Fixie Agent as a virtual machine that runs the program specified by the users query. The Session Runner is responsible for maintaining the running chat log of the session, and providing this context to the Fixie Agent. For example, if the following query were something vague, like \"When is it?\" , the Fixie Agent could disambiguate this to mean \"When is the meeting that you just scheduled?\" based on the session history provided by the Session Runner. For each step in the program, the Fixie Agent calls out to the Router Agent to determine which Agent(s) need to be invoked to run that step of the query. The Router Agent consults the Agent Registry, which contains metadata about each Agent, including the Agents name, owner, and (critically) the sample queries that the Agent can support. For example, the GitHub agent can support a wide range of queries about GitHub-related things, such as \"How many pull requests are open in fixie-ai/fixie?\" . When an Agent is registered with the system, it stores its sample queries in the registry, which the Router Agent uses to determine which queries should be routed to that Agent. The Router determines which Agent to send the query to by using a neural search that maps the users query into a high-dimensional embedding space, and compares it to the sample queries for each of the Agents in the system. The Router sends the users query to the Agent that most closely matches the sample queries for that Agent. The Agent (in this case, perhaps the Google Calendar Agent) gets the query and executes it. This is typically done by using a large language model such as GPT-3 to interpret the query and invoke one or more external systems to generate a response. In the case of the example query given above, this would entail querying the users own calendar for available time slots, querying Zachs calendar for available time slots, finding a suitable time that works for both parties, and then scheduling the meeting. Well describe this process in more detail in the Agent Execution section below. Finally, the response from the Agent is returned up the chain back to the Fixie Agent, which may decide to compose and send a final response to the user, or invoke other steps of the program involving other Agents. The response message is stored in the Session associated with this query, as well as returned to the client application. (The response path is not shown on the diagram for sake of simplicity.)","title":"Example query flow"},{"location":"architecture/#query-message-format","text":"Queries in Fixie consist of two parts: A plain-text Message along with zero or more Embeds. Concretely, a query message in Fixie is a JSON object that might contain: { \"text\" : \"Mask out the background in #1\" , \"embeds\" : { \"1\" : { \"content_type\" : \"image/png\" , \"uri\" : \"https://app.fixie.ai/attachment/21cfa1...\" , } } An Embed is very much like an email attachment: it is a binary object with an associated MIME type, such as image/png or text/plain , that is carried along with the query. Agents can access the Embeds associated with the query, and optionally create new Embeds that represent the result of some data processing or generation. As an example, the DALL-E and Stable Diffusion Agents both create Embeds for the images they generate. The Masker agent takes an image Embed and generates a binary mask representing portions of the image that contain a given object or material (e.g.,whatever is in the background of the image). Embeds are immutable once created. They are stored in a Fixie-managed cloud storage bucket, and are passed by reference (specifically, using a signed URL) along with the query. The text of the query can refer to an Embed using its key in the message. In the above example, the Embed key is 1 , and the query refers to it using #1 .","title":"Query message format"},{"location":"architecture/#creating-an-agent","text":"A Fixie Agent is just a program that accepts a query (text with optional embeds) in the format shown above, and returns a reply in the same format. An Agent can run anywhere on the Internet; Fixie only needs to know the URL to post the query message to over HTTP. The simplest possible Agent, implemented in Python, might look like this: from flask import Flask , request app = Flask ( __name__ ) @app . route ( \"/\" , methods = [ \"POST\" ]) def agent (): query = request . json [ \"text\" ] embeds = request . json [ \"embeds\" ] # Do something with the query... return { \"text\" : \"Hello, world!\" } That\u2019s it! Sending a POST request to the Agent\u2019s URL will return a reply \"Hello, world!\" . Of course, most Fixie Agents will want to use a large language model to process incoming queries and generate responses. There are two ways of doing this in Fixie.","title":"Creating an Agent"},{"location":"architecture/#fully-custom-agents","text":"An Agent can essentially do anything it likes with the input query. The most common pattern here is to directly call a Large Language Model. on its own, e.g., via the OpenAI GPT-3 API. Fixie is agnostic as to how the Agent performs its query processing; it could use GPT-3, a fine-tuned variant like InstructGPT, or a fully custom model provided by the Agent developer or a third party. Libraries like LangChain are sometimes helpful in interfacing the LLM to external code. Instead of using an LLM directly, an Agent can also just be a simple wrapper around a third party AI-powered service that can perform tasks such as text summarization, text generation, search, etc. Building an Agent that wraps, for example, Jasper.ai , Instructive.ai, or Copy.ai is quite easy to do. The benefit of this approach is that those siloed products suddenly become interconnected and composable with the rest of the capabilities in the Fixie ecosystem.","title":"Fully custom Agents"},{"location":"architecture/#code-shot-agents","text":"In addition to the roll your own approach with custom Agents, Fixie provides a novel programming model for building Agents that we call Code Shots . In Large Language Models, the term few shots refers to a set of examples that can be provided to the model that instructs it to perform a specific task. Code Shots are essentially few shots enhanced with embedded code. This is probably best understood through an example. The following Code Shots manifest creates an Agent that understands how to translate English queries into stock price lookups: import fixieai import requests BASE_PROMPT = \"I am an Agent that answers questions about stock prices.\" FEW_SHOTS = \"\"\"Q: What is the current price for SYMBOL? Ask Func[quote]: SYMBOL Func[quote] says: $123.45 A: The current price for SYMBOL is $123.45. Q: SYMBOL share price Ask Func[quote]: SYMBOL Func[quote] says: $34.52 A: The share price for SYMBOL is $34.52. Q: Price for SYMBOL Ask Func[quote]: SYMBOL Func[quote] says: $99.11 A: The share price for SYMBOL is $99.11 \"\"\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS ) API_KEY = \"...\" @agent . register_func () def quote ( query ): symbol = query . message . text url = f \"https://www.alphavantage.co/query?function=GLOBAL_QUOTE&apikey= { API_KEY } &symbol= { symbol } \" response = requests . get ( url ) raw_price = response . json ()[ \"Global Quote\" ][ \"05. price\" ] dot = raw_price . index ( \".\" ) return raw_price [: dot + 3 ] agent . serve ( \"stockquote\" ) This is the entire code for the stock quote Agent. The code manifest consists of a set of few-shot examples (example queries and responses), coupled with a little bit of Python code that knows how to invoke an external API to fetch a stock quote. With Code Shots, the Agents functionality is partitioned across two domains: the language processing (done centrally, by Fixie), and the low-level Func invocations (done within the Agent's own sandbox, either in the customers infrastructure or within an environment that is hosted by us). Because a Func does not need to perform any language processing, it is just a simple function! Let\u2019s walk through what happens when a query comes into a Code Shot Agent. The Agent gets a query like \"What is the stock price for GOOG?\" Fixie takes the users query, along with the few-shot examples in the Code Shots manifest, and passes them to a LLM for processing. Note that this language processing is being done centrally, by Fixie, meaning we can automatically select the best LLM and prompt to handle the query, as well as augment the prompt with relevant context and session history. 3. In this case, the output of the LLM will be something like Ask Func[quote]: GOOG . This is basically saying that Fixie needs to invoke this low-level Func to perform the next step of processing. Fixie invokes the Func by sending a REST call over HTTP to the Agents URL, and getting back the response. Fixie then feeds the Funcs response back into the LLM, again with the appropriate prompt and context, to continue processing the query. In this case, the LLM will generate a response like \"A: The share price for GOOG is $105.22\" . 5. The final reply is sent back to the client, or the Agent that issued the original query. There are a few key things to note about Code Shots. First, they make it really easy to build new Agents, since the only thing the developer needs to do is write a few English-language examples of what the Agent does, along with, possibly, one or more simple Funcs that hook into the query processing logic. Second, Funcs need not be private to individual Agents: We are building an entire library of Funcs that Agents can use, including Funcs that evaluate simple computational expressions, fetch data over HTTP, and so forth. Many Agents can be built without implementing any new Funcs, just by calling existing ones.","title":"Code Shot Agents"},{"location":"architecture/#registering-an-agent","text":"Fixie users can create and register their own Agents in the system either via the GraphQL API or through the web interface. The only thing needed to create an Agent is to give it a name, a short description of what it does, and a URL to which Agent queries should be sent.","title":"Registering an Agent"},{"location":"architecture/#authentication","text":"Fixie ensures that all requests flowing through the system are associated with an end user. A user can get a Fixie account by visiting the web UI (https://app.fixie.ai) and signing up using email, a Google account, or a GitHub account. To access the Fixie GraphQL API, the user can get an API key from their profile page on the site. The API key must be provided in an Authorization: Bearer header when making API calls. The API key itself is a JWT, signed by the Fixie service, that identifies the user associated with the query. When Fixie sends a request to an Agent, the request carries with it a JWT (again, signed by Fixie) that identifies the user and the chat session ID. The Agent can verify that an incoming query is in fact coming from Fixie by checking the signature of this JWT. When the Agent wishes to send a query to another Agent, or invoke one of the API endpoints provided by Fixie, it must provide this JWT to prove that the request is being made in the context of an actual user query.","title":"Authentication"},{"location":"architecture/#usage-limits","text":"Fixie imposes generous usage limits on individual users and Agents to prevent abuse. We currently have a per-user daily limit of 1000 queries. If this turns out not to be adequate we can raise the limit or allow users to purchase additional credits. Agents invoking Fixie APIs, such as the User Storage mechanism described below, also have a rate limit on those calls. Code Shot Agents that use Fixies language processing capabilities will additionally have a limit on the number of tokens they can pass through the Fixie-provided LLM API in a given time period.","title":"Usage limits"},{"location":"architecture/#user-storage","text":"Agents often need to maintain state associated with a given user or chat session in which they are involved. While Agents could simply implement their own mechanism for this (e.g., writing data to a database or a cloud storage bucket), we provide a simple API in Fixie for this purpose. Fixies User Storage component is a simple key-value store, allowing Agents to store and retrieve binary blobs associated with an Agent-provided key. This is akin to cookies in a browser context, allowing Agents to stash away information that they might need to access later.","title":"User Storage"},{"location":"cli/","text":"Fixie CLI Reference This page provides documentation for the Fixie command line tool. fixie Command-line interface to the Fixie platform. Usage: fixie [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit . agent Agent-related commands. Usage: fixie agent [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit . delete Delete an agent. Usage: fixie agent delete [ OPTIONS ] HANDLE Options: -- help Show this message and exit . deploy Deploy the current agent. Usage: fixie agent deploy [ OPTIONS ] [ PATH ] Options: -- metadata - only Only publish metadata and refresh , do not redeploy . -- help Show this message and exit . init Creates an agent.yaml file. Usage: fixie agent init [ OPTIONS ] Options: -- handle TEXT -- description TEXT -- entry - point TEXT -- more - info - url TEXT -- public BOOLEAN -- requirement TEXT Additional requirements for requirements . txt . Can be specified multiple times . -- help Show this message and exit . list List agents. Usage: fixie agent list [ OPTIONS ] Options: -- verbose Enable verbose output . -- help Show this message and exit . serve Serve the current agent locally via a publicly-accessible URL. Usage: fixie agent serve [ OPTIONS ] [ PATH ] Options: -- host TEXT -- port INTEGER -- tunnel / -- no - tunnel ( default enabled ) Create a tunnel using localhost . run . -- reload / -- no - reload ( default enabled ) Reload automatically . -- help Show this message and exit . show Show an agent. Usage: fixie agent show [ OPTIONS ] AGENT_ID Options: -- help Show this message and exit . auth Authorizes fixie to access Fixie platform. Usage: fixie auth [ OPTIONS ] Options: -- force Forces authentication , even if the user is authenticated . -- help Show this message and exit . deploy Deploy the current agent. Usage: fixie deploy [ OPTIONS ] [ PATH ] Options: -- metadata - only Only publish metadata and refresh , do not redeploy . -- help Show this message and exit . init Creates an agent.yaml file. Usage: fixie init [ OPTIONS ] Options: -- handle TEXT -- description TEXT -- entry - point TEXT -- more - info - url TEXT -- public BOOLEAN -- requirement TEXT Additional requirements for requirements . txt . Can be specified multiple times . -- help Show this message and exit . new Creates a new session and opens it. Usage: fixie new [ OPTIONS ] [ MESSAGE ] Options: -- web Open the session in the web interface . - a , -- agent TEXT A specific agent to talk to . If unset , `fixie` is used . -- help Show this message and exit . serve Serve the current agent locally via a publicly-accessible URL. Usage: fixie serve [ OPTIONS ] [ PATH ] Options: -- host TEXT -- port INTEGER -- tunnel / -- no - tunnel ( default enabled ) Create a tunnel using localhost . run . -- reload / -- no - reload ( default enabled ) Reload automatically . -- help Show this message and exit . session Session-related commands. Usage: fixie session [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit . list Lists sessions. Usage: fixie session list [ OPTIONS ] Options: -- help Show this message and exit . new Creates a new session and opens it. Usage: fixie session new [ OPTIONS ] [ MESSAGE ] Options: -- web Open the session in the web interface . - a , -- agent TEXT A specific agent to talk to . If unset , `fixie` is used . -- help Show this message and exit . open Opens a session. Usage: fixie session open [ OPTIONS ] SESSION_ID Options: -- web Open the session in the web interface . -- help Show this message and exit .","title":"CLI"},{"location":"cli/#fixie-cli-reference","text":"This page provides documentation for the Fixie command line tool.","title":"Fixie CLI Reference"},{"location":"cli/#fixie","text":"Command-line interface to the Fixie platform. Usage: fixie [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit .","title":"fixie"},{"location":"cli/#agent","text":"Agent-related commands. Usage: fixie agent [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit .","title":"agent"},{"location":"cli/#delete","text":"Delete an agent. Usage: fixie agent delete [ OPTIONS ] HANDLE Options: -- help Show this message and exit .","title":"delete"},{"location":"cli/#deploy","text":"Deploy the current agent. Usage: fixie agent deploy [ OPTIONS ] [ PATH ] Options: -- metadata - only Only publish metadata and refresh , do not redeploy . -- help Show this message and exit .","title":"deploy"},{"location":"cli/#init","text":"Creates an agent.yaml file. Usage: fixie agent init [ OPTIONS ] Options: -- handle TEXT -- description TEXT -- entry - point TEXT -- more - info - url TEXT -- public BOOLEAN -- requirement TEXT Additional requirements for requirements . txt . Can be specified multiple times . -- help Show this message and exit .","title":"init"},{"location":"cli/#list","text":"List agents. Usage: fixie agent list [ OPTIONS ] Options: -- verbose Enable verbose output . -- help Show this message and exit .","title":"list"},{"location":"cli/#serve","text":"Serve the current agent locally via a publicly-accessible URL. Usage: fixie agent serve [ OPTIONS ] [ PATH ] Options: -- host TEXT -- port INTEGER -- tunnel / -- no - tunnel ( default enabled ) Create a tunnel using localhost . run . -- reload / -- no - reload ( default enabled ) Reload automatically . -- help Show this message and exit .","title":"serve"},{"location":"cli/#show","text":"Show an agent. Usage: fixie agent show [ OPTIONS ] AGENT_ID Options: -- help Show this message and exit .","title":"show"},{"location":"cli/#auth","text":"Authorizes fixie to access Fixie platform. Usage: fixie auth [ OPTIONS ] Options: -- force Forces authentication , even if the user is authenticated . -- help Show this message and exit .","title":"auth"},{"location":"cli/#deploy_1","text":"Deploy the current agent. Usage: fixie deploy [ OPTIONS ] [ PATH ] Options: -- metadata - only Only publish metadata and refresh , do not redeploy . -- help Show this message and exit .","title":"deploy"},{"location":"cli/#init_1","text":"Creates an agent.yaml file. Usage: fixie init [ OPTIONS ] Options: -- handle TEXT -- description TEXT -- entry - point TEXT -- more - info - url TEXT -- public BOOLEAN -- requirement TEXT Additional requirements for requirements . txt . Can be specified multiple times . -- help Show this message and exit .","title":"init"},{"location":"cli/#new","text":"Creates a new session and opens it. Usage: fixie new [ OPTIONS ] [ MESSAGE ] Options: -- web Open the session in the web interface . - a , -- agent TEXT A specific agent to talk to . If unset , `fixie` is used . -- help Show this message and exit .","title":"new"},{"location":"cli/#serve_1","text":"Serve the current agent locally via a publicly-accessible URL. Usage: fixie serve [ OPTIONS ] [ PATH ] Options: -- host TEXT -- port INTEGER -- tunnel / -- no - tunnel ( default enabled ) Create a tunnel using localhost . run . -- reload / -- no - reload ( default enabled ) Reload automatically . -- help Show this message and exit .","title":"serve"},{"location":"cli/#session","text":"Session-related commands. Usage: fixie session [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit .","title":"session"},{"location":"cli/#list_1","text":"Lists sessions. Usage: fixie session list [ OPTIONS ] Options: -- help Show this message and exit .","title":"list"},{"location":"cli/#new_1","text":"Creates a new session and opens it. Usage: fixie session new [ OPTIONS ] [ MESSAGE ] Options: -- web Open the session in the web interface . - a , -- agent TEXT A specific agent to talk to . If unset , `fixie` is used . -- help Show this message and exit .","title":"new"},{"location":"cli/#open","text":"Opens a session. Usage: fixie session open [ OPTIONS ] SESSION_ID Options: -- web Open the session in the web interface . -- help Show this message and exit .","title":"open"},{"location":"docs-readme/","text":"To add a new theme run the following commands: poetry add theme-name just install just serve-docs Make sure the new theme name is used in mkdocs.yml file under theme/name. You should be able to checkout the docs on local page at http://127.0.0.1:8000/","title":"Docs readme"},{"location":"python-agent-api/","text":"Fixie Agent Python API Reference This module holds objects that represent the API interface by which Agents talk to Fixie ecosystem. AgentQuery A standalone query sent to a Fixie agent. Source code in fixieai/agents/api.py 58 59 60 61 62 63 64 65 66 67 68 69 @pydantic_dataclasses . dataclass class AgentQuery : \"\"\"A standalone query sent to a Fixie agent.\"\"\" # The contents of the query. message : Message # This is an access token associated with the user for whom this query was # created. Agents wishing to make queries to other agents, or to other # Fixie services, should carry this token in the query so that it # can be tied back to the original user. access_token : Optional [ str ] = None AgentResponse A response message from an Agent. Source code in fixieai/agents/api.py 72 73 74 75 76 77 @pydantic_dataclasses . dataclass class AgentResponse : \"\"\"A response message from an Agent.\"\"\" # The text of the response message. message : Message Embed An Embed represents a binary object attached to a Message. Source code in fixieai/agents/api.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @pydantic_dataclasses . dataclass class Embed : \"\"\"An Embed represents a binary object attached to a Message.\"\"\" # The MIME content type of the object, e.g., \"image/png\" or \"application/json\". content_type : str # A public URL where the object can be downloaded. This can be a data URI. uri : str @property def content ( self ) -> bytes : \"\"\"Retrieves the content for this Embed object.\"\"\" if self . uri . startswith ( \"data:\" ): return base64 . b64decode ( self . uri . split ( \",\" )[ 1 ]) return requests . get ( self . uri ) . content @content . setter def content ( self , content : bytes ): \"\"\"Sets the content of the Embed object as a data URI.\"\"\" self . uri = f \"data:base64, { base64 . b64encode ( content ) . decode ( 'utf-8' ) } \" @property def text ( self ) -> str : \"\"\"Retrieves the content of the Embed object as a string.\"\"\" return self . content . decode ( \"utf-8\" ) @text . setter def text ( self , text : str ): \"\"\"Sets the content of the Embed object as a string.\"\"\" self . content = text . encode ( \"utf-8\" ) content : bytes writable property Retrieves the content for this Embed object. text : str writable property Retrieves the content of the Embed object as a string. Message A Message represents a single message sent to a Fixie agent. Source code in fixieai/agents/api.py 47 48 49 50 51 52 53 54 55 @pydantic_dataclasses . dataclass class Message : \"\"\"A Message represents a single message sent to a Fixie agent.\"\"\" # The text of the message. text : str # A mapping of embed keys to Embed objects. embeds : Dict [ str , Embed ] = dataclasses . field ( default_factory = dict ) AgentMetadata Metadata for a Fixie CodeShot Agent. This will get sent to the Fixie platform upon handshake. Source code in fixieai/agents/code_shot.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 @pydantic_dataclasses . dataclass class AgentMetadata : \"\"\"Metadata for a Fixie CodeShot Agent. This will get sent to the Fixie platform upon handshake. \"\"\" base_prompt : str few_shots : List [ str ] corpora : Optional [ List [ corpora . DocumentCorpus ]] = None conversational : bool = False def __post_init__ ( self ): utils . strip_prompt_lines ( self ) utils . validate_code_shot_agent ( self ) CodeShotAgent A CodeShot agent. To make a CodeShot agent, simply pass a BASE_PROMPT and FEW_SHOTS: BASE_PROMPT = \"A summary of what this agent does; how it does it; and its personality \" FEW_SHOTS = ''' Q: <Sample query that this agent supports> A: <Desired response for this query> Q: <Another sample query> A: <Desired response for this query> ''' agent = CodeShotAgent(BASE_PROMPT, FEW_SHOTS) You can have FEW_SHOTS as a single string of all your few-shots separated by 2 new lines, or as an explicit list of one few-shot per index. Your few-shots may reach out to other Agents in the fixie ecosystem by \"Ask Agent[agent_id]: \", or reach out to some python functions by \"Ask Func[func_name]: \". There are a series of default runtime Func s provided by the platform available for your agents to consume. For a full list of default runtime Func s, refer to: http://docs.fixie.ai/XXX You may also need to write your own python functions here to be consumed by your agent. To make a function accessible by an agent, you'd need to register it by @agent.register_func . Example: @agent.register_func def func_name ( query : fixieai . Message ) -> ReturnType : ... , where ReturnType is one of `str` , `fixieai.Message` , or `fixie.AgentResponse` . Note that in the above, we are using the decorator @agent.register_func to register this function with the agent instance we just created. To check out the default Func s that are provided in Fixie, see: http://docs.fixie.ai/XXX Source code in fixieai/agents/code_shot.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 class CodeShotAgent : \"\"\"A CodeShot agent. To make a CodeShot agent, simply pass a BASE_PROMPT and FEW_SHOTS: BASE_PROMPT = \"A summary of what this agent does; how it does it; and its personality\" FEW_SHOTS = ''' Q: <Sample query that this agent supports> A: <Desired response for this query> Q: <Another sample query> A: <Desired response for this query> ''' agent = CodeShotAgent(BASE_PROMPT, FEW_SHOTS) You can have FEW_SHOTS as a single string of all your few-shots separated by 2 new lines, or as an explicit list of one few-shot per index. Your few-shots may reach out to other Agents in the fixie ecosystem by \"Ask Agent[agent_id]: <query to pass>\", or reach out to some python functions by \"Ask Func[func_name]: <query to pass>\". There are a series of default runtime `Func`s provided by the platform available for your agents to consume. For a full list of default runtime `Func`s, refer to: http://docs.fixie.ai/XXX You may also need to write your own python functions here to be consumed by your agent. To make a function accessible by an agent, you'd need to register it by `@agent.register_func`. Example: @agent.register_func def func_name(query: fixieai.Message) -> ReturnType: ... , where ReturnType is one of `str`, `fixieai.Message`, or `fixie.AgentResponse`. Note that in the above, we are using the decorator `@agent.register_func` to register this function with the agent instance we just created. To check out the default `Func`s that are provided in Fixie, see: http://docs.fixie.ai/XXX \"\"\" def __init__ ( self , base_prompt : str , few_shots : Union [ str , List [ str ]], corpora : Optional [ List [ corpora . DocumentCorpus ]] = None , conversational : bool = False , oauth_params : Optional [ oauth . OAuthParams ] = None , ): if isinstance ( few_shots , str ): few_shots = _split_few_shots ( few_shots ) self . base_prompt = base_prompt self . few_shots = few_shots self . corpora = corpora self . conversational = conversational self . oauth_params = oauth_params self . _funcs : Dict [ str , Callable ] = {} self . _jwks_client = jwt . PyJWKClient ( constants . FIXIE_JWKS_URL ) if oauth_params is not None : # Register default Funcs. self . register_func ( _oauth ) def serve ( self , agent_id : Optional [ str ] = None , host : str = \"0.0.0.0\" , port : int = 8181 ): \"\"\"Starts serving the current agent at `{host}:{port}` via uvicorn. If agent_id is specified, this pings Fixie upon startup to fetch the latest prompt and fewshots. Args: agent_id: The qualified agent id (`username/handle`) host: The address to start listening at. port: The port number to start listening at. \"\"\" uvicorn . run ( self . app ( agent_id ), host = host , port = port ) def app ( self , agent_id : Optional [ str ] = None ) -> fastapi . FastAPI : \"\"\"Returns a fastapi.FastAPI application that serves the agent. If agent_id is specified, this pings Fixie upon startup to fetch the latest prompt and fewshots. Args: agent_id: The qualified agent id (`username/handle`) \"\"\" fast_api = fastapi . FastAPI () fast_api . include_router ( self . api_router ()) agent_id = agent_id if agent_id : fast_api . add_event_handler ( \"startup\" , functools . partial ( _ping_fixie_async , agent_id ) ) return fast_api def api_router ( self ) -> fastapi . APIRouter : \"\"\"Returns a fastapi.APIRouter object that serves the agent.\"\"\" router = fastapi . APIRouter () router . add_api_route ( \"/\" , self . _handshake , methods = [ \"GET\" ]) router . add_api_route ( \"/ {func_name} \" , self . _serve_func , methods = [ \"POST\" ]) return router def register_func ( self , func : Optional [ Callable ] = None , * , func_name : Optional [ str ] = None ) -> Callable : \"\"\"A function decorator to register `Func`s with this agent. This decorator will not change the callable itself. Usage: agent = CodeShotAgent(base_prompt, few_shots) @agent.register_func def func(query): ... Optional Decorator Args: func_name: Optional function name to register this function by. If unset, the function name will be used. \"\"\" if func is None : # Func is not passed in. It's the decorator being created. return functools . partial ( self . register_func , func_name = func_name ) if func_name is not None : if not ACCEPTED_FUNC_NAMES . fullmatch ( func_name ): raise ValueError ( f \"Function names may only be alphanumerics, got { func_name !r} .\" ) utils . validate_registered_pyfunc ( func , self ) name = func_name or func . __name__ if name in self . _funcs : raise ValueError ( f \"Func[ { name } ] is already registered with agent.\" ) self . _funcs [ name ] = func return func def _handshake ( self ) -> fastapi . Response : \"\"\"Returns the agent's metadata in YAML format.\"\"\" metadata = AgentMetadata ( self . base_prompt , self . few_shots , self . corpora , self . conversational ) yaml_content = yaml . dump ( dataclasses . asdict ( metadata )) return fastapi . Response ( yaml_content , media_type = \"application/yaml\" ) def _serve_func ( self , func_name : str , query : api . AgentQuery , credentials : fastapi . security . HTTPAuthorizationCredentials = fastapi . Depends ( fastapi . security . HTTPBearer () ), ) -> api . AgentResponse : \"\"\"Verifies the request is a valid request from Fixie, and dispatches it to the appropriate function. \"\"\" token_claims = _VerifiedTokenClaims . from_token ( credentials . credentials , self . _jwks_client ) if token_claims is None : raise fastapi . HTTPException ( status_code = 403 , detail = \"Invalid token\" ) elif ( query . access_token is not None and query . access_token != credentials . credentials ): raise fastapi . HTTPException ( status_code = 403 , detail = \"Mismatched tokens\" ) else : query . access_token = credentials . credentials try : pyfunc = self . _funcs [ func_name ] except KeyError : raise fastapi . HTTPException ( status_code = 404 , detail = f \"Func[ { func_name } ] doesn't exist\" ) kwargs = self . _get_func_kwargs ( query , token_claims , inspect . signature ( pyfunc ) . parameters . keys () ) output = pyfunc ( ** kwargs ) try : return _wrap_with_agent_response ( output ) except TypeError : raise TypeError ( f \"Func[ { func_name } ] returned unexpected output of type { type ( output ) } .\" ) def _get_func_kwargs ( self , query : api . AgentQuery , token_claims : _VerifiedTokenClaims , arg_names : Iterable [ str ], ) -> Dict [ str , Any ]: kwargs : Dict [ str , Any ] = {} for arg_name in arg_names : if arg_name == \"query\" : kwargs [ arg_name ] = query . message elif arg_name == \"user_storage\" : kwargs [ arg_name ] = user_storage . UserStorage ( query , token_claims . agent_id ) elif arg_name == \"oauth_handler\" : assert self . oauth_params , \"oauth_params is not set\" kwargs [ arg_name ] = oauth . OAuthHandler ( self . oauth_params , query , token_claims . agent_id ) else : raise ValueError ( f \"Found unknown argument { arg_name !r} .\" ) return kwargs api_router () Returns a fastapi.APIRouter object that serves the agent. Source code in fixieai/agents/code_shot.py 151 152 153 154 155 156 def api_router ( self ) -> fastapi . APIRouter : \"\"\"Returns a fastapi.APIRouter object that serves the agent.\"\"\" router = fastapi . APIRouter () router . add_api_route ( \"/\" , self . _handshake , methods = [ \"GET\" ]) router . add_api_route ( \"/ {func_name} \" , self . _serve_func , methods = [ \"POST\" ]) return router app ( agent_id = None ) Returns a fastapi.FastAPI application that serves the agent. If agent_id is specified, this pings Fixie upon startup to fetch the latest prompt and fewshots. Parameters: Name Type Description Default agent_id Optional [ str ] The qualified agent id ( username/handle ) None Source code in fixieai/agents/code_shot.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def app ( self , agent_id : Optional [ str ] = None ) -> fastapi . FastAPI : \"\"\"Returns a fastapi.FastAPI application that serves the agent. If agent_id is specified, this pings Fixie upon startup to fetch the latest prompt and fewshots. Args: agent_id: The qualified agent id (`username/handle`) \"\"\" fast_api = fastapi . FastAPI () fast_api . include_router ( self . api_router ()) agent_id = agent_id if agent_id : fast_api . add_event_handler ( \"startup\" , functools . partial ( _ping_fixie_async , agent_id ) ) return fast_api register_func ( func = None , * , func_name = None ) A function decorator to register Func s with this agent. This decorator will not change the callable itself. Usage agent = CodeShotAgent(base_prompt, few_shots) @agent.register_func def func(query): ... Optional Decorator Args func_name: Optional function name to register this function by. If unset, the function name will be used. Source code in fixieai/agents/code_shot.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def register_func ( self , func : Optional [ Callable ] = None , * , func_name : Optional [ str ] = None ) -> Callable : \"\"\"A function decorator to register `Func`s with this agent. This decorator will not change the callable itself. Usage: agent = CodeShotAgent(base_prompt, few_shots) @agent.register_func def func(query): ... Optional Decorator Args: func_name: Optional function name to register this function by. If unset, the function name will be used. \"\"\" if func is None : # Func is not passed in. It's the decorator being created. return functools . partial ( self . register_func , func_name = func_name ) if func_name is not None : if not ACCEPTED_FUNC_NAMES . fullmatch ( func_name ): raise ValueError ( f \"Function names may only be alphanumerics, got { func_name !r} .\" ) utils . validate_registered_pyfunc ( func , self ) name = func_name or func . __name__ if name in self . _funcs : raise ValueError ( f \"Func[ { name } ] is already registered with agent.\" ) self . _funcs [ name ] = func return func serve ( agent_id = None , host = '0.0.0.0' , port = 8181 ) Starts serving the current agent at {host}:{port} via uvicorn. If agent_id is specified, this pings Fixie upon startup to fetch the latest prompt and fewshots. Parameters: Name Type Description Default agent_id Optional [ str ] The qualified agent id ( username/handle ) None host str The address to start listening at. '0.0.0.0' port int The port number to start listening at. 8181 Source code in fixieai/agents/code_shot.py 120 121 122 123 124 125 126 127 128 129 130 131 132 def serve ( self , agent_id : Optional [ str ] = None , host : str = \"0.0.0.0\" , port : int = 8181 ): \"\"\"Starts serving the current agent at `{host}:{port}` via uvicorn. If agent_id is specified, this pings Fixie upon startup to fetch the latest prompt and fewshots. Args: agent_id: The qualified agent id (`username/handle`) host: The address to start listening at. port: The port number to start listening at. \"\"\" uvicorn . run ( self . app ( agent_id ), host = host , port = port ) OAuthHandler OAuthHandler that wraps around a (OAuthParams, query) to authenticate. This client object provides 3 main method credentials: Returns current user's OAuth access token, or None if they are not authenticated. get_authorization_url: Returns a url that the users can click to authenticate themselves. authorize: Exchanges a received access code (from auth redirect callback) for an access token. If successful, user's storage is updated. Source code in fixieai/agents/oauth.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 class OAuthHandler : \"\"\" OAuthHandler that wraps around a (OAuthParams, query) to authenticate. This client object provides 3 main method: * credentials: Returns current user's OAuth access token, or None if they are not authenticated. * get_authorization_url: Returns a url that the users can click to authenticate themselves. * authorize: Exchanges a received access code (from auth redirect callback) for an access token. If successful, user's storage is updated. \"\"\" # OAuth keys reserved in UserStorage OAUTH_STATE_KEY = \"_oauth_state\" OAUTH_TOKEN_KEY = \"_oauth_token\" def __init__ ( self , oauth_params : OAuthParams , query : api . AgentQuery , agent_id : str , ): self . _storage = user_storage . UserStorage ( query , agent_id ) self . _oauth_params = oauth_params self . _agent_id = agent_id def get_authorization_url ( self ) -> str : \"\"\"Returns a URL to launch the authorization flow.\"\"\" auth_state = f \" { self . _agent_id } : { secrets . token_urlsafe () } \" data = { \"response_type\" : \"code\" , \"access_type\" : \"offline\" , \"client_id\" : self . _oauth_params . client_id , \"scope\" : \" \" . join ( self . _oauth_params . scopes ), \"state\" : auth_state , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } url = self . _oauth_params . auth_uri + \"?\" + parse . urlencode ( data ) # Store auth_state in UserStorage for validation later. self . _storage [ self . OAUTH_STATE_KEY ] = auth_state return url def user_token ( self ) -> Optional [ str ]: \"\"\"Returns current user's OAuth credentials, or None if not authorized.\"\"\" try : creds_json = self . _storage [ self . OAUTH_TOKEN_KEY ] except KeyError : return None if not isinstance ( creds_json , str ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not an OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None try : creds = _OAuthCredentials . from_json ( creds_json ) except ( TypeError , LookupError , ValueError ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not a valid _OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None if creds . expired : logging . debug ( f \"Credentials expired at { creds . expiry } \" ) if not creds . refresh_token : logging . warning ( \"No refresh token available\" ) return None logging . debug ( \"Refreshing credentials...\" ) creds . refresh ( self . _oauth_params ) self . _save_credentials ( creds ) # Save refreshed token to UserStorage return creds . access_token def authorize ( self , state : str , code : str ): \"\"\"Authorize the received access `code` against the client secret. If successful, the credentials will be saved in user storage. \"\"\" expected_state = self . _storage [ self . OAUTH_STATE_KEY ] if state != expected_state : logging . warning ( f \"Unknown state token, expected: { expected_state !r} actual: { state !r} \" ) raise ValueError ( f \"Unknown state token\" ) data = { \"grant_type\" : \"authorization_code\" , \"client_id\" : self . _oauth_params . client_id , \"client_secret\" : self . _oauth_params . client_secret , \"code\" : code , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } response = _send_authorize_request ( self . _oauth_params . token_uri , data ) logging . debug ( f \"OAuth auth request succeeded, lifetime= { response . expires_in } \" f \"refreshable= { response . refresh_token is not None } \" ) credentials = _OAuthCredentials ( response . access_token , _get_expiry ( response . expires_in ), response . refresh_token , ) self . _save_credentials ( credentials ) def _save_credentials ( self , credentials : \"_OAuthCredentials\" ): self . _storage [ self . OAUTH_TOKEN_KEY ] = credentials . to_json () authorize ( state , code ) Authorize the received access code against the client secret. If successful, the credentials will be saved in user storage. Source code in fixieai/agents/oauth.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def authorize ( self , state : str , code : str ): \"\"\"Authorize the received access `code` against the client secret. If successful, the credentials will be saved in user storage. \"\"\" expected_state = self . _storage [ self . OAUTH_STATE_KEY ] if state != expected_state : logging . warning ( f \"Unknown state token, expected: { expected_state !r} actual: { state !r} \" ) raise ValueError ( f \"Unknown state token\" ) data = { \"grant_type\" : \"authorization_code\" , \"client_id\" : self . _oauth_params . client_id , \"client_secret\" : self . _oauth_params . client_secret , \"code\" : code , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } response = _send_authorize_request ( self . _oauth_params . token_uri , data ) logging . debug ( f \"OAuth auth request succeeded, lifetime= { response . expires_in } \" f \"refreshable= { response . refresh_token is not None } \" ) credentials = _OAuthCredentials ( response . access_token , _get_expiry ( response . expires_in ), response . refresh_token , ) self . _save_credentials ( credentials ) get_authorization_url () Returns a URL to launch the authorization flow. Source code in fixieai/agents/oauth.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def get_authorization_url ( self ) -> str : \"\"\"Returns a URL to launch the authorization flow.\"\"\" auth_state = f \" { self . _agent_id } : { secrets . token_urlsafe () } \" data = { \"response_type\" : \"code\" , \"access_type\" : \"offline\" , \"client_id\" : self . _oauth_params . client_id , \"scope\" : \" \" . join ( self . _oauth_params . scopes ), \"state\" : auth_state , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } url = self . _oauth_params . auth_uri + \"?\" + parse . urlencode ( data ) # Store auth_state in UserStorage for validation later. self . _storage [ self . OAUTH_STATE_KEY ] = auth_state return url user_token () Returns current user's OAuth credentials, or None if not authorized. Source code in fixieai/agents/oauth.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def user_token ( self ) -> Optional [ str ]: \"\"\"Returns current user's OAuth credentials, or None if not authorized.\"\"\" try : creds_json = self . _storage [ self . OAUTH_TOKEN_KEY ] except KeyError : return None if not isinstance ( creds_json , str ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not an OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None try : creds = _OAuthCredentials . from_json ( creds_json ) except ( TypeError , LookupError , ValueError ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not a valid _OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None if creds . expired : logging . debug ( f \"Credentials expired at { creds . expiry } \" ) if not creds . refresh_token : logging . warning ( \"No refresh token available\" ) return None logging . debug ( \"Refreshing credentials...\" ) creds . refresh ( self . _oauth_params ) self . _save_credentials ( creds ) # Save refreshed token to UserStorage return creds . access_token OAuthParams dataclass Encapsulates OAuth parameters, including secret, auth uri, and the scope. Agents who want to use OAuth flow, should declare their secrets via this object. Source code in fixieai/agents/oauth.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @dataclasses . dataclass class OAuthParams : \"\"\"Encapsulates OAuth parameters, including secret, auth uri, and the scope. Agents who want to use OAuth flow, should declare their secrets via this object. \"\"\" client_id : str client_secret : str auth_uri : str token_uri : str scopes : List [ str ] @classmethod def from_client_secrets_file ( cls , secrets_path : str , scopes : List [ str ] ) -> \"OAuthParams\" : \"\"\"Initializes OAuth from a secrets file, e.g., as obtained from the Google Cloud Console. Args: secrets_path: Path to a json file holding secret values. scopes: A list of scopes that access needs to be requested for. \"\"\" with open ( secrets_path , \"r\" ) as file : data = json . load ( file ) secrets = data [ \"web\" ] or data [ \"installed\" ] return cls ( secrets [ \"client_id\" ], secrets [ \"client_secret\" ], secrets [ \"auth_uri\" ], secrets [ \"token_uri\" ], scopes , ) from_client_secrets_file ( secrets_path , scopes ) classmethod Initializes OAuth from a secrets file, e.g., as obtained from the Google Cloud Console. Parameters: Name Type Description Default secrets_path str Path to a json file holding secret values. required scopes List [ str ] A list of scopes that access needs to be requested for. required Source code in fixieai/agents/oauth.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @classmethod def from_client_secrets_file ( cls , secrets_path : str , scopes : List [ str ] ) -> \"OAuthParams\" : \"\"\"Initializes OAuth from a secrets file, e.g., as obtained from the Google Cloud Console. Args: secrets_path: Path to a json file holding secret values. scopes: A list of scopes that access needs to be requested for. \"\"\" with open ( secrets_path , \"r\" ) as file : data = json . load ( file ) secrets = data [ \"web\" ] or data [ \"installed\" ] return cls ( secrets [ \"client_id\" ], secrets [ \"client_secret\" ], secrets [ \"auth_uri\" ], secrets [ \"token_uri\" ], scopes , ) UserStorage Bases: MutableMapping [ str , UserStorageType ] UserStorage provides a dict-like interface to a user-specific storage. Usage: from fixieai import AgentQuery, Message query = AgentQuery( ... Message(\"incoming query\"), ... access_token=\"fake-access-token\" ... ) storage = UserStorage(query, \"fake-agent\") storage[\"key\"] = \"value\" storage[\"complex-key\"] = {\"key1\": {\"key2\": [12, False, None, b\"binary\"]}} assert len(storage) == 2 assert storage \"complex-key\" \"key2\" == b\"binary\" Source code in fixieai/agents/user_storage.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class UserStorage ( MutableMapping [ str , UserStorageType ]): \"\"\"UserStorage provides a dict-like interface to a user-specific storage. Usage: >>> from fixieai import AgentQuery, Message >>> query = AgentQuery( ... Message(\"incoming query\"), ... access_token=\"fake-access-token\" ... ) >>> storage = UserStorage(query, \"fake-agent\") >>> storage[\"key\"] = \"value\" >>> storage[\"complex-key\"] = {\"key1\": {\"key2\": [12, False, None, b\"binary\"]}} >>> assert len(storage) == 2 >>> assert storage[\"complex-key\"][\"key1\"][\"key2\"][-1] == b\"binary\" \"\"\" def __init__ ( self , query : \"AgentQuery\" , agent_id : str , userstorage_url : str = constants . FIXIE_USER_STORAGE_URL , ): # TODO(hessam): Remove agent_id from args once access_token includes agent_id # as well. self . _agent_id = agent_id self . _userstorage_url = userstorage_url self . _session = requests . Session () self . _session . headers . update ({ \"Authorization\" : f \"Bearer { query . access_token } \" }) def __setitem__ ( self , key : str , value : UserStorageType ): url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" response = self . _session . post ( url , json = { \"data\" : to_json ( value )}) response . raise_for_status () def __getitem__ ( self , key : str ) -> UserStorageType : url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" try : response = self . _session . get ( url ) response . raise_for_status () return from_json ( response . json ()[ \"data\" ]) except requests . exceptions . HTTPError as e : raise KeyError ( f \"Key { key } not found\" ) from e def __contains__ ( self , key : object ) -> bool : url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" try : response = self . _session . head ( url ) response . raise_for_status () return True except requests . exceptions . HTTPError as e : return False def __delitem__ ( self , key : str ): url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" try : response = self . _session . delete ( url ) response . raise_for_status () except requests . exceptions . HTTPError as e : raise KeyError ( f \"Key { key } not found\" ) from e def _get_all_keys ( self ): url = f \" { self . _userstorage_url } / { self . _agent_id } \" response = self . _session . get ( url ) response . raise_for_status () return [ value [ \"key\" ] for value in response . json ()] def __iter__ ( self ): return iter ( self . _get_all_keys ()) def __len__ ( self ): return len ( self . _get_all_keys ()) from_json ( json_dump ) Deserializes a UserStorageType from a JSON string. Source code in fixieai/agents/user_storage.py 101 102 103 def from_json ( json_dump : str ) -> UserStorageType : \"\"\"Deserializes a UserStorageType from a JSON string.\"\"\" return from_json_type ( json . loads ( json_dump )) from_json_type ( obj ) Decodes a JsonType to UserStorageType. Source code in fixieai/agents/user_storage.py 118 119 120 121 122 123 124 125 126 127 def from_json_type ( obj : JsonType ) -> UserStorageType : \"\"\"Decodes a JsonType to UserStorageType.\"\"\" if _is_bytes_encoded_json_dict ( obj ): return base64 . b64decode ( obj [ \"data\" ]) # type: ignore elif isinstance ( obj , list ): return [ from_json_type ( item ) for item in obj ] elif isinstance ( obj , dict ): return { key : from_json_type ( value ) for key , value in obj . items ()} else : return obj to_json ( obj ) Serialize a UserStorageType to a JSON string. Source code in fixieai/agents/user_storage.py 96 97 98 def to_json ( obj : UserStorageType ) -> str : \"\"\"Serialize a UserStorageType to a JSON string.\"\"\" return json . dumps ( to_json_type ( obj )) to_json_type ( obj ) Encodes a UserStorageType to JsonType. Source code in fixieai/agents/user_storage.py 106 107 108 109 110 111 112 113 114 115 def to_json_type ( obj : UserStorageType ) -> JsonType : \"\"\"Encodes a UserStorageType to JsonType.\"\"\" if isinstance ( obj , bytes ): return { \"type\" : \"_bytes_ascii\" , \"data\" : base64 . b64encode ( obj ) . decode ( \"ASCII\" )} elif isinstance ( obj , list ): return [ to_json_type ( item ) for item in obj ] elif isinstance ( obj , dict ): return { key : to_json_type ( value ) for key , value in obj . items ()} else : return obj FewshotLinePattern Bases: enum . Enum Source code in fixieai/agents/utils.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 class FewshotLinePattern ( enum . Enum ): QUERY = re . compile ( r \"^Q:\" ) AGENT_SAYS = re . compile ( r \"^Agent\\[\\w+] says:\" ) FUNC_SAYS = re . compile ( r \"^Func\\[\\w+] says:\" ) ASK_AGENT = re . compile ( r \"^Ask Agent\\[\\w+]:\" ) ASK_FUNC = re . compile ( r \"^Ask Func\\[\\w+]:\" ) RESPONSE = re . compile ( r \"^A:\" ) NO_PATTERN : None = None @classmethod def pattern ( cls , line : str ) -> \"FewshotLinePattern\" : \"\"\"Returns the matched PromptPattern for a given line.\"\"\" if \" \\n \" in line : raise ValueError ( \"Cannot get the pattern for a multi-line text. Patterns must be \" \"extracted one line at a time.\" ) pattern_matches = [ prompt_pattern for prompt_pattern in cls if prompt_pattern is not cls . NO_PATTERN and prompt_pattern . value . match ( line ) ] if len ( pattern_matches ) > 1 : raise RuntimeError ( f \"More than one pattern ( { pattern_matches } ) matched the line { line !r} .\" ) elif len ( pattern_matches ) == 1 : return pattern_matches [ 0 ] else : return cls . NO_PATTERN pattern ( line ) classmethod Returns the matched PromptPattern for a given line. Source code in fixieai/agents/utils.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 @classmethod def pattern ( cls , line : str ) -> \"FewshotLinePattern\" : \"\"\"Returns the matched PromptPattern for a given line.\"\"\" if \" \\n \" in line : raise ValueError ( \"Cannot get the pattern for a multi-line text. Patterns must be \" \"extracted one line at a time.\" ) pattern_matches = [ prompt_pattern for prompt_pattern in cls if prompt_pattern is not cls . NO_PATTERN and prompt_pattern . value . match ( line ) ] if len ( pattern_matches ) > 1 : raise RuntimeError ( f \"More than one pattern ( { pattern_matches } ) matched the line { line !r} .\" ) elif len ( pattern_matches ) == 1 : return pattern_matches [ 0 ] else : return cls . NO_PATTERN strip_prompt_lines ( agent_metadata ) Strips all prompt lines. Source code in fixieai/agents/utils.py 15 16 17 18 19 def strip_prompt_lines ( agent_metadata : code_shot . AgentMetadata ): \"\"\"Strips all prompt lines.\"\"\" agent_metadata . base_prompt = _strip_all_lines ( agent_metadata . base_prompt ) for i , fewshot in enumerate ( agent_metadata . few_shots ): agent_metadata . few_shots [ i ] = _strip_all_lines ( fewshot ) validate_code_shot_agent ( agent_metadata ) A client-side validation of few_shots and agent. Source code in fixieai/agents/utils.py 22 23 24 25 26 def validate_code_shot_agent ( agent_metadata : code_shot . AgentMetadata ): \"\"\"A client-side validation of few_shots and agent.\"\"\" _validate_base_prompt ( agent_metadata . base_prompt ) for fewshot in agent_metadata . few_shots : _validate_few_shot_prompt ( fewshot ) validate_registered_pyfunc ( func , agent ) Validates func 's signature to be a valid CodeShot Func. Parameters: Name Type Description Default func Callable The function to be validated. required agent code_shot . CodeShotAgent The CodeShotAgent that this func is going to be registered for. required Source code in fixieai/agents/utils.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def validate_registered_pyfunc ( func : Callable , agent : code_shot . CodeShotAgent ): \"\"\"Validates `func`'s signature to be a valid CodeShot Func. Args: func: The function to be validated. agent: The CodeShotAgent that this func is going to be registered for. \"\"\" # Delayed import to avoid circular dependency from fixieai.agents import api from fixieai.agents import oauth from fixieai.agents import user_storage ALLOWED_FUNC_PARAMS = { \"query\" : api . Message , \"user_storage\" : user_storage . UserStorage , \"oauth_handler\" : oauth . OAuthHandler , } # Validate that func is a function type. if not inspect . isfunction ( func ): raise TypeError ( f \"Registered function { func !r} is not a function, but a { type ( func ) !r} .\" ) signature = inspect . signature ( func ) func_name = func . __name__ params = signature . parameters # Validate that there are not var args (*args or **kwargs). if any ( param . kind in ( param . VAR_KEYWORD , param . VAR_POSITIONAL ) for param in params . values () ): raise TypeError ( f \"Registered function { func_name } cannot accept variable args: { params !r} .\" ) # Validate that all argument names are known. unknown_params = set ( params . keys ()) - set ( ALLOWED_FUNC_PARAMS . keys ()) if unknown_params : raise TypeError ( f \"Registered function { func_name } gets unknown arguments { unknown_params } . \" f \"List of allowed Func arguments are { list ( ALLOWED_FUNC_PARAMS . keys ()) } .\" ) # Check the type annotations match what's expected, if func is type annotated. type_hints = get_type_hints ( func ) for arg_name , arg_type in ALLOWED_FUNC_PARAMS . items (): if arg_name in type_hints and type_hints [ arg_name ] != arg_type : raise TypeError ( f \"Expected argument { arg_name !r} to be of type { arg_type !r} , but it's \" f \"typed as { type_hints [ arg_name ] !r} .\" ) if \"return\" in type_hints and type_hints [ \"return\" ] not in ( api . AgentResponse , api . Message , str , ): raise TypeError ( f \"Expected registered function to return an AgentResponse, a Message, \" f \"or str but it returns { type_hints [ 'return' ] } .\" ) # Some custom checks. if \"oauth_handler\" in params and agent . oauth_params is None : raise TypeError ( f \"Function { func_name } who accepts 'oauth_handler' as an argument cannot \" f \"be registered with agent { agent !r} who hasn't set 'oauth_params' in its \" \"constructor.\" ) return func","title":"Python Agent API"},{"location":"python-agent-api/#fixie-agent-python-api-reference","text":"This module holds objects that represent the API interface by which Agents talk to Fixie ecosystem.","title":"Fixie Agent Python API Reference"},{"location":"python-agent-api/#fixieai.agents.api.AgentQuery","text":"A standalone query sent to a Fixie agent. Source code in fixieai/agents/api.py 58 59 60 61 62 63 64 65 66 67 68 69 @pydantic_dataclasses . dataclass class AgentQuery : \"\"\"A standalone query sent to a Fixie agent.\"\"\" # The contents of the query. message : Message # This is an access token associated with the user for whom this query was # created. Agents wishing to make queries to other agents, or to other # Fixie services, should carry this token in the query so that it # can be tied back to the original user. access_token : Optional [ str ] = None","title":"AgentQuery"},{"location":"python-agent-api/#fixieai.agents.api.AgentResponse","text":"A response message from an Agent. Source code in fixieai/agents/api.py 72 73 74 75 76 77 @pydantic_dataclasses . dataclass class AgentResponse : \"\"\"A response message from an Agent.\"\"\" # The text of the response message. message : Message","title":"AgentResponse"},{"location":"python-agent-api/#fixieai.agents.api.Embed","text":"An Embed represents a binary object attached to a Message. Source code in fixieai/agents/api.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @pydantic_dataclasses . dataclass class Embed : \"\"\"An Embed represents a binary object attached to a Message.\"\"\" # The MIME content type of the object, e.g., \"image/png\" or \"application/json\". content_type : str # A public URL where the object can be downloaded. This can be a data URI. uri : str @property def content ( self ) -> bytes : \"\"\"Retrieves the content for this Embed object.\"\"\" if self . uri . startswith ( \"data:\" ): return base64 . b64decode ( self . uri . split ( \",\" )[ 1 ]) return requests . get ( self . uri ) . content @content . setter def content ( self , content : bytes ): \"\"\"Sets the content of the Embed object as a data URI.\"\"\" self . uri = f \"data:base64, { base64 . b64encode ( content ) . decode ( 'utf-8' ) } \" @property def text ( self ) -> str : \"\"\"Retrieves the content of the Embed object as a string.\"\"\" return self . content . decode ( \"utf-8\" ) @text . setter def text ( self , text : str ): \"\"\"Sets the content of the Embed object as a string.\"\"\" self . content = text . encode ( \"utf-8\" )","title":"Embed"},{"location":"python-agent-api/#fixieai.agents.api.Embed.content","text":"Retrieves the content for this Embed object.","title":"content"},{"location":"python-agent-api/#fixieai.agents.api.Embed.text","text":"Retrieves the content of the Embed object as a string.","title":"text"},{"location":"python-agent-api/#fixieai.agents.api.Message","text":"A Message represents a single message sent to a Fixie agent. Source code in fixieai/agents/api.py 47 48 49 50 51 52 53 54 55 @pydantic_dataclasses . dataclass class Message : \"\"\"A Message represents a single message sent to a Fixie agent.\"\"\" # The text of the message. text : str # A mapping of embed keys to Embed objects. embeds : Dict [ str , Embed ] = dataclasses . field ( default_factory = dict )","title":"Message"},{"location":"python-agent-api/#fixieai.agents.code_shot.AgentMetadata","text":"Metadata for a Fixie CodeShot Agent. This will get sent to the Fixie platform upon handshake. Source code in fixieai/agents/code_shot.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 @pydantic_dataclasses . dataclass class AgentMetadata : \"\"\"Metadata for a Fixie CodeShot Agent. This will get sent to the Fixie platform upon handshake. \"\"\" base_prompt : str few_shots : List [ str ] corpora : Optional [ List [ corpora . DocumentCorpus ]] = None conversational : bool = False def __post_init__ ( self ): utils . strip_prompt_lines ( self ) utils . validate_code_shot_agent ( self )","title":"AgentMetadata"},{"location":"python-agent-api/#fixieai.agents.code_shot.CodeShotAgent","text":"A CodeShot agent. To make a CodeShot agent, simply pass a BASE_PROMPT and FEW_SHOTS: BASE_PROMPT = \"A summary of what this agent does; how it does it; and its personality \" FEW_SHOTS = ''' Q: <Sample query that this agent supports> A: <Desired response for this query> Q: <Another sample query> A: <Desired response for this query> ''' agent = CodeShotAgent(BASE_PROMPT, FEW_SHOTS) You can have FEW_SHOTS as a single string of all your few-shots separated by 2 new lines, or as an explicit list of one few-shot per index. Your few-shots may reach out to other Agents in the fixie ecosystem by \"Ask Agent[agent_id]: \", or reach out to some python functions by \"Ask Func[func_name]: \". There are a series of default runtime Func s provided by the platform available for your agents to consume. For a full list of default runtime Func s, refer to: http://docs.fixie.ai/XXX You may also need to write your own python functions here to be consumed by your agent. To make a function accessible by an agent, you'd need to register it by @agent.register_func . Example: @agent.register_func def func_name ( query : fixieai . Message ) -> ReturnType : ... , where ReturnType is one of `str` , `fixieai.Message` , or `fixie.AgentResponse` . Note that in the above, we are using the decorator @agent.register_func to register this function with the agent instance we just created. To check out the default Func s that are provided in Fixie, see: http://docs.fixie.ai/XXX Source code in fixieai/agents/code_shot.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 class CodeShotAgent : \"\"\"A CodeShot agent. To make a CodeShot agent, simply pass a BASE_PROMPT and FEW_SHOTS: BASE_PROMPT = \"A summary of what this agent does; how it does it; and its personality\" FEW_SHOTS = ''' Q: <Sample query that this agent supports> A: <Desired response for this query> Q: <Another sample query> A: <Desired response for this query> ''' agent = CodeShotAgent(BASE_PROMPT, FEW_SHOTS) You can have FEW_SHOTS as a single string of all your few-shots separated by 2 new lines, or as an explicit list of one few-shot per index. Your few-shots may reach out to other Agents in the fixie ecosystem by \"Ask Agent[agent_id]: <query to pass>\", or reach out to some python functions by \"Ask Func[func_name]: <query to pass>\". There are a series of default runtime `Func`s provided by the platform available for your agents to consume. For a full list of default runtime `Func`s, refer to: http://docs.fixie.ai/XXX You may also need to write your own python functions here to be consumed by your agent. To make a function accessible by an agent, you'd need to register it by `@agent.register_func`. Example: @agent.register_func def func_name(query: fixieai.Message) -> ReturnType: ... , where ReturnType is one of `str`, `fixieai.Message`, or `fixie.AgentResponse`. Note that in the above, we are using the decorator `@agent.register_func` to register this function with the agent instance we just created. To check out the default `Func`s that are provided in Fixie, see: http://docs.fixie.ai/XXX \"\"\" def __init__ ( self , base_prompt : str , few_shots : Union [ str , List [ str ]], corpora : Optional [ List [ corpora . DocumentCorpus ]] = None , conversational : bool = False , oauth_params : Optional [ oauth . OAuthParams ] = None , ): if isinstance ( few_shots , str ): few_shots = _split_few_shots ( few_shots ) self . base_prompt = base_prompt self . few_shots = few_shots self . corpora = corpora self . conversational = conversational self . oauth_params = oauth_params self . _funcs : Dict [ str , Callable ] = {} self . _jwks_client = jwt . PyJWKClient ( constants . FIXIE_JWKS_URL ) if oauth_params is not None : # Register default Funcs. self . register_func ( _oauth ) def serve ( self , agent_id : Optional [ str ] = None , host : str = \"0.0.0.0\" , port : int = 8181 ): \"\"\"Starts serving the current agent at `{host}:{port}` via uvicorn. If agent_id is specified, this pings Fixie upon startup to fetch the latest prompt and fewshots. Args: agent_id: The qualified agent id (`username/handle`) host: The address to start listening at. port: The port number to start listening at. \"\"\" uvicorn . run ( self . app ( agent_id ), host = host , port = port ) def app ( self , agent_id : Optional [ str ] = None ) -> fastapi . FastAPI : \"\"\"Returns a fastapi.FastAPI application that serves the agent. If agent_id is specified, this pings Fixie upon startup to fetch the latest prompt and fewshots. Args: agent_id: The qualified agent id (`username/handle`) \"\"\" fast_api = fastapi . FastAPI () fast_api . include_router ( self . api_router ()) agent_id = agent_id if agent_id : fast_api . add_event_handler ( \"startup\" , functools . partial ( _ping_fixie_async , agent_id ) ) return fast_api def api_router ( self ) -> fastapi . APIRouter : \"\"\"Returns a fastapi.APIRouter object that serves the agent.\"\"\" router = fastapi . APIRouter () router . add_api_route ( \"/\" , self . _handshake , methods = [ \"GET\" ]) router . add_api_route ( \"/ {func_name} \" , self . _serve_func , methods = [ \"POST\" ]) return router def register_func ( self , func : Optional [ Callable ] = None , * , func_name : Optional [ str ] = None ) -> Callable : \"\"\"A function decorator to register `Func`s with this agent. This decorator will not change the callable itself. Usage: agent = CodeShotAgent(base_prompt, few_shots) @agent.register_func def func(query): ... Optional Decorator Args: func_name: Optional function name to register this function by. If unset, the function name will be used. \"\"\" if func is None : # Func is not passed in. It's the decorator being created. return functools . partial ( self . register_func , func_name = func_name ) if func_name is not None : if not ACCEPTED_FUNC_NAMES . fullmatch ( func_name ): raise ValueError ( f \"Function names may only be alphanumerics, got { func_name !r} .\" ) utils . validate_registered_pyfunc ( func , self ) name = func_name or func . __name__ if name in self . _funcs : raise ValueError ( f \"Func[ { name } ] is already registered with agent.\" ) self . _funcs [ name ] = func return func def _handshake ( self ) -> fastapi . Response : \"\"\"Returns the agent's metadata in YAML format.\"\"\" metadata = AgentMetadata ( self . base_prompt , self . few_shots , self . corpora , self . conversational ) yaml_content = yaml . dump ( dataclasses . asdict ( metadata )) return fastapi . Response ( yaml_content , media_type = \"application/yaml\" ) def _serve_func ( self , func_name : str , query : api . AgentQuery , credentials : fastapi . security . HTTPAuthorizationCredentials = fastapi . Depends ( fastapi . security . HTTPBearer () ), ) -> api . AgentResponse : \"\"\"Verifies the request is a valid request from Fixie, and dispatches it to the appropriate function. \"\"\" token_claims = _VerifiedTokenClaims . from_token ( credentials . credentials , self . _jwks_client ) if token_claims is None : raise fastapi . HTTPException ( status_code = 403 , detail = \"Invalid token\" ) elif ( query . access_token is not None and query . access_token != credentials . credentials ): raise fastapi . HTTPException ( status_code = 403 , detail = \"Mismatched tokens\" ) else : query . access_token = credentials . credentials try : pyfunc = self . _funcs [ func_name ] except KeyError : raise fastapi . HTTPException ( status_code = 404 , detail = f \"Func[ { func_name } ] doesn't exist\" ) kwargs = self . _get_func_kwargs ( query , token_claims , inspect . signature ( pyfunc ) . parameters . keys () ) output = pyfunc ( ** kwargs ) try : return _wrap_with_agent_response ( output ) except TypeError : raise TypeError ( f \"Func[ { func_name } ] returned unexpected output of type { type ( output ) } .\" ) def _get_func_kwargs ( self , query : api . AgentQuery , token_claims : _VerifiedTokenClaims , arg_names : Iterable [ str ], ) -> Dict [ str , Any ]: kwargs : Dict [ str , Any ] = {} for arg_name in arg_names : if arg_name == \"query\" : kwargs [ arg_name ] = query . message elif arg_name == \"user_storage\" : kwargs [ arg_name ] = user_storage . UserStorage ( query , token_claims . agent_id ) elif arg_name == \"oauth_handler\" : assert self . oauth_params , \"oauth_params is not set\" kwargs [ arg_name ] = oauth . OAuthHandler ( self . oauth_params , query , token_claims . agent_id ) else : raise ValueError ( f \"Found unknown argument { arg_name !r} .\" ) return kwargs","title":"CodeShotAgent"},{"location":"python-agent-api/#fixieai.agents.code_shot.CodeShotAgent.api_router","text":"Returns a fastapi.APIRouter object that serves the agent. Source code in fixieai/agents/code_shot.py 151 152 153 154 155 156 def api_router ( self ) -> fastapi . APIRouter : \"\"\"Returns a fastapi.APIRouter object that serves the agent.\"\"\" router = fastapi . APIRouter () router . add_api_route ( \"/\" , self . _handshake , methods = [ \"GET\" ]) router . add_api_route ( \"/ {func_name} \" , self . _serve_func , methods = [ \"POST\" ]) return router","title":"api_router()"},{"location":"python-agent-api/#fixieai.agents.code_shot.CodeShotAgent.app","text":"Returns a fastapi.FastAPI application that serves the agent. If agent_id is specified, this pings Fixie upon startup to fetch the latest prompt and fewshots. Parameters: Name Type Description Default agent_id Optional [ str ] The qualified agent id ( username/handle ) None Source code in fixieai/agents/code_shot.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def app ( self , agent_id : Optional [ str ] = None ) -> fastapi . FastAPI : \"\"\"Returns a fastapi.FastAPI application that serves the agent. If agent_id is specified, this pings Fixie upon startup to fetch the latest prompt and fewshots. Args: agent_id: The qualified agent id (`username/handle`) \"\"\" fast_api = fastapi . FastAPI () fast_api . include_router ( self . api_router ()) agent_id = agent_id if agent_id : fast_api . add_event_handler ( \"startup\" , functools . partial ( _ping_fixie_async , agent_id ) ) return fast_api","title":"app()"},{"location":"python-agent-api/#fixieai.agents.code_shot.CodeShotAgent.register_func","text":"A function decorator to register Func s with this agent. This decorator will not change the callable itself. Usage agent = CodeShotAgent(base_prompt, few_shots) @agent.register_func def func(query): ... Optional Decorator Args func_name: Optional function name to register this function by. If unset, the function name will be used. Source code in fixieai/agents/code_shot.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def register_func ( self , func : Optional [ Callable ] = None , * , func_name : Optional [ str ] = None ) -> Callable : \"\"\"A function decorator to register `Func`s with this agent. This decorator will not change the callable itself. Usage: agent = CodeShotAgent(base_prompt, few_shots) @agent.register_func def func(query): ... Optional Decorator Args: func_name: Optional function name to register this function by. If unset, the function name will be used. \"\"\" if func is None : # Func is not passed in. It's the decorator being created. return functools . partial ( self . register_func , func_name = func_name ) if func_name is not None : if not ACCEPTED_FUNC_NAMES . fullmatch ( func_name ): raise ValueError ( f \"Function names may only be alphanumerics, got { func_name !r} .\" ) utils . validate_registered_pyfunc ( func , self ) name = func_name or func . __name__ if name in self . _funcs : raise ValueError ( f \"Func[ { name } ] is already registered with agent.\" ) self . _funcs [ name ] = func return func","title":"register_func()"},{"location":"python-agent-api/#fixieai.agents.code_shot.CodeShotAgent.serve","text":"Starts serving the current agent at {host}:{port} via uvicorn. If agent_id is specified, this pings Fixie upon startup to fetch the latest prompt and fewshots. Parameters: Name Type Description Default agent_id Optional [ str ] The qualified agent id ( username/handle ) None host str The address to start listening at. '0.0.0.0' port int The port number to start listening at. 8181 Source code in fixieai/agents/code_shot.py 120 121 122 123 124 125 126 127 128 129 130 131 132 def serve ( self , agent_id : Optional [ str ] = None , host : str = \"0.0.0.0\" , port : int = 8181 ): \"\"\"Starts serving the current agent at `{host}:{port}` via uvicorn. If agent_id is specified, this pings Fixie upon startup to fetch the latest prompt and fewshots. Args: agent_id: The qualified agent id (`username/handle`) host: The address to start listening at. port: The port number to start listening at. \"\"\" uvicorn . run ( self . app ( agent_id ), host = host , port = port )","title":"serve()"},{"location":"python-agent-api/#fixieai.agents.oauth.OAuthHandler","text":"OAuthHandler that wraps around a (OAuthParams, query) to authenticate. This client object provides 3 main method credentials: Returns current user's OAuth access token, or None if they are not authenticated. get_authorization_url: Returns a url that the users can click to authenticate themselves. authorize: Exchanges a received access code (from auth redirect callback) for an access token. If successful, user's storage is updated. Source code in fixieai/agents/oauth.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 class OAuthHandler : \"\"\" OAuthHandler that wraps around a (OAuthParams, query) to authenticate. This client object provides 3 main method: * credentials: Returns current user's OAuth access token, or None if they are not authenticated. * get_authorization_url: Returns a url that the users can click to authenticate themselves. * authorize: Exchanges a received access code (from auth redirect callback) for an access token. If successful, user's storage is updated. \"\"\" # OAuth keys reserved in UserStorage OAUTH_STATE_KEY = \"_oauth_state\" OAUTH_TOKEN_KEY = \"_oauth_token\" def __init__ ( self , oauth_params : OAuthParams , query : api . AgentQuery , agent_id : str , ): self . _storage = user_storage . UserStorage ( query , agent_id ) self . _oauth_params = oauth_params self . _agent_id = agent_id def get_authorization_url ( self ) -> str : \"\"\"Returns a URL to launch the authorization flow.\"\"\" auth_state = f \" { self . _agent_id } : { secrets . token_urlsafe () } \" data = { \"response_type\" : \"code\" , \"access_type\" : \"offline\" , \"client_id\" : self . _oauth_params . client_id , \"scope\" : \" \" . join ( self . _oauth_params . scopes ), \"state\" : auth_state , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } url = self . _oauth_params . auth_uri + \"?\" + parse . urlencode ( data ) # Store auth_state in UserStorage for validation later. self . _storage [ self . OAUTH_STATE_KEY ] = auth_state return url def user_token ( self ) -> Optional [ str ]: \"\"\"Returns current user's OAuth credentials, or None if not authorized.\"\"\" try : creds_json = self . _storage [ self . OAUTH_TOKEN_KEY ] except KeyError : return None if not isinstance ( creds_json , str ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not an OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None try : creds = _OAuthCredentials . from_json ( creds_json ) except ( TypeError , LookupError , ValueError ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not a valid _OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None if creds . expired : logging . debug ( f \"Credentials expired at { creds . expiry } \" ) if not creds . refresh_token : logging . warning ( \"No refresh token available\" ) return None logging . debug ( \"Refreshing credentials...\" ) creds . refresh ( self . _oauth_params ) self . _save_credentials ( creds ) # Save refreshed token to UserStorage return creds . access_token def authorize ( self , state : str , code : str ): \"\"\"Authorize the received access `code` against the client secret. If successful, the credentials will be saved in user storage. \"\"\" expected_state = self . _storage [ self . OAUTH_STATE_KEY ] if state != expected_state : logging . warning ( f \"Unknown state token, expected: { expected_state !r} actual: { state !r} \" ) raise ValueError ( f \"Unknown state token\" ) data = { \"grant_type\" : \"authorization_code\" , \"client_id\" : self . _oauth_params . client_id , \"client_secret\" : self . _oauth_params . client_secret , \"code\" : code , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } response = _send_authorize_request ( self . _oauth_params . token_uri , data ) logging . debug ( f \"OAuth auth request succeeded, lifetime= { response . expires_in } \" f \"refreshable= { response . refresh_token is not None } \" ) credentials = _OAuthCredentials ( response . access_token , _get_expiry ( response . expires_in ), response . refresh_token , ) self . _save_credentials ( credentials ) def _save_credentials ( self , credentials : \"_OAuthCredentials\" ): self . _storage [ self . OAUTH_TOKEN_KEY ] = credentials . to_json ()","title":"OAuthHandler"},{"location":"python-agent-api/#fixieai.agents.oauth.OAuthHandler.authorize","text":"Authorize the received access code against the client secret. If successful, the credentials will be saved in user storage. Source code in fixieai/agents/oauth.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def authorize ( self , state : str , code : str ): \"\"\"Authorize the received access `code` against the client secret. If successful, the credentials will be saved in user storage. \"\"\" expected_state = self . _storage [ self . OAUTH_STATE_KEY ] if state != expected_state : logging . warning ( f \"Unknown state token, expected: { expected_state !r} actual: { state !r} \" ) raise ValueError ( f \"Unknown state token\" ) data = { \"grant_type\" : \"authorization_code\" , \"client_id\" : self . _oauth_params . client_id , \"client_secret\" : self . _oauth_params . client_secret , \"code\" : code , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } response = _send_authorize_request ( self . _oauth_params . token_uri , data ) logging . debug ( f \"OAuth auth request succeeded, lifetime= { response . expires_in } \" f \"refreshable= { response . refresh_token is not None } \" ) credentials = _OAuthCredentials ( response . access_token , _get_expiry ( response . expires_in ), response . refresh_token , ) self . _save_credentials ( credentials )","title":"authorize()"},{"location":"python-agent-api/#fixieai.agents.oauth.OAuthHandler.get_authorization_url","text":"Returns a URL to launch the authorization flow. Source code in fixieai/agents/oauth.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def get_authorization_url ( self ) -> str : \"\"\"Returns a URL to launch the authorization flow.\"\"\" auth_state = f \" { self . _agent_id } : { secrets . token_urlsafe () } \" data = { \"response_type\" : \"code\" , \"access_type\" : \"offline\" , \"client_id\" : self . _oauth_params . client_id , \"scope\" : \" \" . join ( self . _oauth_params . scopes ), \"state\" : auth_state , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } url = self . _oauth_params . auth_uri + \"?\" + parse . urlencode ( data ) # Store auth_state in UserStorage for validation later. self . _storage [ self . OAUTH_STATE_KEY ] = auth_state return url","title":"get_authorization_url()"},{"location":"python-agent-api/#fixieai.agents.oauth.OAuthHandler.user_token","text":"Returns current user's OAuth credentials, or None if not authorized. Source code in fixieai/agents/oauth.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def user_token ( self ) -> Optional [ str ]: \"\"\"Returns current user's OAuth credentials, or None if not authorized.\"\"\" try : creds_json = self . _storage [ self . OAUTH_TOKEN_KEY ] except KeyError : return None if not isinstance ( creds_json , str ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not an OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None try : creds = _OAuthCredentials . from_json ( creds_json ) except ( TypeError , LookupError , ValueError ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not a valid _OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None if creds . expired : logging . debug ( f \"Credentials expired at { creds . expiry } \" ) if not creds . refresh_token : logging . warning ( \"No refresh token available\" ) return None logging . debug ( \"Refreshing credentials...\" ) creds . refresh ( self . _oauth_params ) self . _save_credentials ( creds ) # Save refreshed token to UserStorage return creds . access_token","title":"user_token()"},{"location":"python-agent-api/#fixieai.agents.oauth.OAuthParams","text":"Encapsulates OAuth parameters, including secret, auth uri, and the scope. Agents who want to use OAuth flow, should declare their secrets via this object. Source code in fixieai/agents/oauth.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @dataclasses . dataclass class OAuthParams : \"\"\"Encapsulates OAuth parameters, including secret, auth uri, and the scope. Agents who want to use OAuth flow, should declare their secrets via this object. \"\"\" client_id : str client_secret : str auth_uri : str token_uri : str scopes : List [ str ] @classmethod def from_client_secrets_file ( cls , secrets_path : str , scopes : List [ str ] ) -> \"OAuthParams\" : \"\"\"Initializes OAuth from a secrets file, e.g., as obtained from the Google Cloud Console. Args: secrets_path: Path to a json file holding secret values. scopes: A list of scopes that access needs to be requested for. \"\"\" with open ( secrets_path , \"r\" ) as file : data = json . load ( file ) secrets = data [ \"web\" ] or data [ \"installed\" ] return cls ( secrets [ \"client_id\" ], secrets [ \"client_secret\" ], secrets [ \"auth_uri\" ], secrets [ \"token_uri\" ], scopes , )","title":"OAuthParams"},{"location":"python-agent-api/#fixieai.agents.oauth.OAuthParams.from_client_secrets_file","text":"Initializes OAuth from a secrets file, e.g., as obtained from the Google Cloud Console. Parameters: Name Type Description Default secrets_path str Path to a json file holding secret values. required scopes List [ str ] A list of scopes that access needs to be requested for. required Source code in fixieai/agents/oauth.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @classmethod def from_client_secrets_file ( cls , secrets_path : str , scopes : List [ str ] ) -> \"OAuthParams\" : \"\"\"Initializes OAuth from a secrets file, e.g., as obtained from the Google Cloud Console. Args: secrets_path: Path to a json file holding secret values. scopes: A list of scopes that access needs to be requested for. \"\"\" with open ( secrets_path , \"r\" ) as file : data = json . load ( file ) secrets = data [ \"web\" ] or data [ \"installed\" ] return cls ( secrets [ \"client_id\" ], secrets [ \"client_secret\" ], secrets [ \"auth_uri\" ], secrets [ \"token_uri\" ], scopes , )","title":"from_client_secrets_file()"},{"location":"python-agent-api/#fixieai.agents.user_storage.UserStorage","text":"Bases: MutableMapping [ str , UserStorageType ] UserStorage provides a dict-like interface to a user-specific storage. Usage: from fixieai import AgentQuery, Message query = AgentQuery( ... Message(\"incoming query\"), ... access_token=\"fake-access-token\" ... ) storage = UserStorage(query, \"fake-agent\") storage[\"key\"] = \"value\" storage[\"complex-key\"] = {\"key1\": {\"key2\": [12, False, None, b\"binary\"]}} assert len(storage) == 2 assert storage \"complex-key\" \"key2\" == b\"binary\" Source code in fixieai/agents/user_storage.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class UserStorage ( MutableMapping [ str , UserStorageType ]): \"\"\"UserStorage provides a dict-like interface to a user-specific storage. Usage: >>> from fixieai import AgentQuery, Message >>> query = AgentQuery( ... Message(\"incoming query\"), ... access_token=\"fake-access-token\" ... ) >>> storage = UserStorage(query, \"fake-agent\") >>> storage[\"key\"] = \"value\" >>> storage[\"complex-key\"] = {\"key1\": {\"key2\": [12, False, None, b\"binary\"]}} >>> assert len(storage) == 2 >>> assert storage[\"complex-key\"][\"key1\"][\"key2\"][-1] == b\"binary\" \"\"\" def __init__ ( self , query : \"AgentQuery\" , agent_id : str , userstorage_url : str = constants . FIXIE_USER_STORAGE_URL , ): # TODO(hessam): Remove agent_id from args once access_token includes agent_id # as well. self . _agent_id = agent_id self . _userstorage_url = userstorage_url self . _session = requests . Session () self . _session . headers . update ({ \"Authorization\" : f \"Bearer { query . access_token } \" }) def __setitem__ ( self , key : str , value : UserStorageType ): url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" response = self . _session . post ( url , json = { \"data\" : to_json ( value )}) response . raise_for_status () def __getitem__ ( self , key : str ) -> UserStorageType : url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" try : response = self . _session . get ( url ) response . raise_for_status () return from_json ( response . json ()[ \"data\" ]) except requests . exceptions . HTTPError as e : raise KeyError ( f \"Key { key } not found\" ) from e def __contains__ ( self , key : object ) -> bool : url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" try : response = self . _session . head ( url ) response . raise_for_status () return True except requests . exceptions . HTTPError as e : return False def __delitem__ ( self , key : str ): url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" try : response = self . _session . delete ( url ) response . raise_for_status () except requests . exceptions . HTTPError as e : raise KeyError ( f \"Key { key } not found\" ) from e def _get_all_keys ( self ): url = f \" { self . _userstorage_url } / { self . _agent_id } \" response = self . _session . get ( url ) response . raise_for_status () return [ value [ \"key\" ] for value in response . json ()] def __iter__ ( self ): return iter ( self . _get_all_keys ()) def __len__ ( self ): return len ( self . _get_all_keys ())","title":"UserStorage"},{"location":"python-agent-api/#fixieai.agents.user_storage.from_json","text":"Deserializes a UserStorageType from a JSON string. Source code in fixieai/agents/user_storage.py 101 102 103 def from_json ( json_dump : str ) -> UserStorageType : \"\"\"Deserializes a UserStorageType from a JSON string.\"\"\" return from_json_type ( json . loads ( json_dump ))","title":"from_json()"},{"location":"python-agent-api/#fixieai.agents.user_storage.from_json_type","text":"Decodes a JsonType to UserStorageType. Source code in fixieai/agents/user_storage.py 118 119 120 121 122 123 124 125 126 127 def from_json_type ( obj : JsonType ) -> UserStorageType : \"\"\"Decodes a JsonType to UserStorageType.\"\"\" if _is_bytes_encoded_json_dict ( obj ): return base64 . b64decode ( obj [ \"data\" ]) # type: ignore elif isinstance ( obj , list ): return [ from_json_type ( item ) for item in obj ] elif isinstance ( obj , dict ): return { key : from_json_type ( value ) for key , value in obj . items ()} else : return obj","title":"from_json_type()"},{"location":"python-agent-api/#fixieai.agents.user_storage.to_json","text":"Serialize a UserStorageType to a JSON string. Source code in fixieai/agents/user_storage.py 96 97 98 def to_json ( obj : UserStorageType ) -> str : \"\"\"Serialize a UserStorageType to a JSON string.\"\"\" return json . dumps ( to_json_type ( obj ))","title":"to_json()"},{"location":"python-agent-api/#fixieai.agents.user_storage.to_json_type","text":"Encodes a UserStorageType to JsonType. Source code in fixieai/agents/user_storage.py 106 107 108 109 110 111 112 113 114 115 def to_json_type ( obj : UserStorageType ) -> JsonType : \"\"\"Encodes a UserStorageType to JsonType.\"\"\" if isinstance ( obj , bytes ): return { \"type\" : \"_bytes_ascii\" , \"data\" : base64 . b64encode ( obj ) . decode ( \"ASCII\" )} elif isinstance ( obj , list ): return [ to_json_type ( item ) for item in obj ] elif isinstance ( obj , dict ): return { key : to_json_type ( value ) for key , value in obj . items ()} else : return obj","title":"to_json_type()"},{"location":"python-agent-api/#fixieai.agents.utils.FewshotLinePattern","text":"Bases: enum . Enum Source code in fixieai/agents/utils.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 class FewshotLinePattern ( enum . Enum ): QUERY = re . compile ( r \"^Q:\" ) AGENT_SAYS = re . compile ( r \"^Agent\\[\\w+] says:\" ) FUNC_SAYS = re . compile ( r \"^Func\\[\\w+] says:\" ) ASK_AGENT = re . compile ( r \"^Ask Agent\\[\\w+]:\" ) ASK_FUNC = re . compile ( r \"^Ask Func\\[\\w+]:\" ) RESPONSE = re . compile ( r \"^A:\" ) NO_PATTERN : None = None @classmethod def pattern ( cls , line : str ) -> \"FewshotLinePattern\" : \"\"\"Returns the matched PromptPattern for a given line.\"\"\" if \" \\n \" in line : raise ValueError ( \"Cannot get the pattern for a multi-line text. Patterns must be \" \"extracted one line at a time.\" ) pattern_matches = [ prompt_pattern for prompt_pattern in cls if prompt_pattern is not cls . NO_PATTERN and prompt_pattern . value . match ( line ) ] if len ( pattern_matches ) > 1 : raise RuntimeError ( f \"More than one pattern ( { pattern_matches } ) matched the line { line !r} .\" ) elif len ( pattern_matches ) == 1 : return pattern_matches [ 0 ] else : return cls . NO_PATTERN","title":"FewshotLinePattern"},{"location":"python-agent-api/#fixieai.agents.utils.FewshotLinePattern.pattern","text":"Returns the matched PromptPattern for a given line. Source code in fixieai/agents/utils.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 @classmethod def pattern ( cls , line : str ) -> \"FewshotLinePattern\" : \"\"\"Returns the matched PromptPattern for a given line.\"\"\" if \" \\n \" in line : raise ValueError ( \"Cannot get the pattern for a multi-line text. Patterns must be \" \"extracted one line at a time.\" ) pattern_matches = [ prompt_pattern for prompt_pattern in cls if prompt_pattern is not cls . NO_PATTERN and prompt_pattern . value . match ( line ) ] if len ( pattern_matches ) > 1 : raise RuntimeError ( f \"More than one pattern ( { pattern_matches } ) matched the line { line !r} .\" ) elif len ( pattern_matches ) == 1 : return pattern_matches [ 0 ] else : return cls . NO_PATTERN","title":"pattern()"},{"location":"python-agent-api/#fixieai.agents.utils.strip_prompt_lines","text":"Strips all prompt lines. Source code in fixieai/agents/utils.py 15 16 17 18 19 def strip_prompt_lines ( agent_metadata : code_shot . AgentMetadata ): \"\"\"Strips all prompt lines.\"\"\" agent_metadata . base_prompt = _strip_all_lines ( agent_metadata . base_prompt ) for i , fewshot in enumerate ( agent_metadata . few_shots ): agent_metadata . few_shots [ i ] = _strip_all_lines ( fewshot )","title":"strip_prompt_lines()"},{"location":"python-agent-api/#fixieai.agents.utils.validate_code_shot_agent","text":"A client-side validation of few_shots and agent. Source code in fixieai/agents/utils.py 22 23 24 25 26 def validate_code_shot_agent ( agent_metadata : code_shot . AgentMetadata ): \"\"\"A client-side validation of few_shots and agent.\"\"\" _validate_base_prompt ( agent_metadata . base_prompt ) for fewshot in agent_metadata . few_shots : _validate_few_shot_prompt ( fewshot )","title":"validate_code_shot_agent()"},{"location":"python-agent-api/#fixieai.agents.utils.validate_registered_pyfunc","text":"Validates func 's signature to be a valid CodeShot Func. Parameters: Name Type Description Default func Callable The function to be validated. required agent code_shot . CodeShotAgent The CodeShotAgent that this func is going to be registered for. required Source code in fixieai/agents/utils.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def validate_registered_pyfunc ( func : Callable , agent : code_shot . CodeShotAgent ): \"\"\"Validates `func`'s signature to be a valid CodeShot Func. Args: func: The function to be validated. agent: The CodeShotAgent that this func is going to be registered for. \"\"\" # Delayed import to avoid circular dependency from fixieai.agents import api from fixieai.agents import oauth from fixieai.agents import user_storage ALLOWED_FUNC_PARAMS = { \"query\" : api . Message , \"user_storage\" : user_storage . UserStorage , \"oauth_handler\" : oauth . OAuthHandler , } # Validate that func is a function type. if not inspect . isfunction ( func ): raise TypeError ( f \"Registered function { func !r} is not a function, but a { type ( func ) !r} .\" ) signature = inspect . signature ( func ) func_name = func . __name__ params = signature . parameters # Validate that there are not var args (*args or **kwargs). if any ( param . kind in ( param . VAR_KEYWORD , param . VAR_POSITIONAL ) for param in params . values () ): raise TypeError ( f \"Registered function { func_name } cannot accept variable args: { params !r} .\" ) # Validate that all argument names are known. unknown_params = set ( params . keys ()) - set ( ALLOWED_FUNC_PARAMS . keys ()) if unknown_params : raise TypeError ( f \"Registered function { func_name } gets unknown arguments { unknown_params } . \" f \"List of allowed Func arguments are { list ( ALLOWED_FUNC_PARAMS . keys ()) } .\" ) # Check the type annotations match what's expected, if func is type annotated. type_hints = get_type_hints ( func ) for arg_name , arg_type in ALLOWED_FUNC_PARAMS . items (): if arg_name in type_hints and type_hints [ arg_name ] != arg_type : raise TypeError ( f \"Expected argument { arg_name !r} to be of type { arg_type !r} , but it's \" f \"typed as { type_hints [ arg_name ] !r} .\" ) if \"return\" in type_hints and type_hints [ \"return\" ] not in ( api . AgentResponse , api . Message , str , ): raise TypeError ( f \"Expected registered function to return an AgentResponse, a Message, \" f \"or str but it returns { type_hints [ 'return' ] } .\" ) # Some custom checks. if \"oauth_handler\" in params and agent . oauth_params is None : raise TypeError ( f \"Function { func_name } who accepts 'oauth_handler' as an argument cannot \" f \"be registered with agent { agent !r} who hasn't set 'oauth_params' in its \" \"constructor.\" ) return func","title":"validate_registered_pyfunc()"},{"location":"python-client-api/","text":"Fixie Client Python API Reference FixieClient FixieClient is a client to the Fixie system. Parameters: Name Type Description Default api_key Optional [ str ] The API key for the Fixie API server. If not provided, the FIXIE_API_KEY environment variable will be used. If that is not set, the authenticated user API key will be used, or a ValueError will be raised if the user is not authenticated. None gqlclient : Client property Return the underlying GraphQL client used by this FixieClient. url : str property Return the URL of the Fixie API server. clone () Return a new FixieClient instance with the same configuration. create_agent ( handle , name , description , query_url = None , func_url = None , more_info_url = None , published = None ) Create a new Agent. Parameters: Name Type Description Default handle str The handle for the new Agent. This must be unique across all Agents owned by this user. required name str The name of the new Agent. required description str A description of the new Agent. required query_url Optional [ str ] The URL of the new Agent's query endpoint. None func_url Optional [ str ] The URL of the new Agent's func endpoint. None more_info_url Optional [ str ] A URL with more information about the new Agent. None published Optional [ bool ] Whether the new Agent should be published. None create_session ( frontend_agent_id = None ) Create a new Session. deploy_agent ( agent_handle , files ) Deploys an agent implementation. get_agent ( agent_id ) Return an existing Agent object. get_agents () Return metadata about all running Fixie Agents. The keys of the returned dictionary are the Agent handles, and the values are dictionaries containing metadata about each Agent. get_current_username () Returns the username of the current user. get_session ( session_id ) Return an existing Session object. get_sessions () Return a list of all session IDs. refresh_agent ( agent_handle ) Indicates that an agent's prompts should be refreshed. get_agents () Return metadata about all Fixie Agents. The keys of the returned dictionary are Agent IDs, and the values are dictionaries containing metadata about each Agent. get_client () Return the global FixieClient instance. get_embeds () Return a list of Embeds. get_session () Return the global Fixie Session instance. query ( text ) Run a query. Session Represents a single session with the Fixie system. Parameters: Name Type Description Default client FixieClient The FixieClient instance to use. required session_id Optional [ str ] The ID of the session to use. If not provided, a new session will be created. None frontend_agent_id : Optional [ str ] property Return the frontend agent ID used by this Fixie client. session_id : Optional [ str ] property Return the session ID used by this Fixie client. session_url : str property Return the URL of the Fixie session. add_message ( text ) Add a message to this Session. Returns the added message text. clone () Return a new Session instance with the same configuration. delete_session () Delete the current session. get_embeds () Return the Embeds attached to this Session. get_messages () Return the messages that make up this session. get_messages_since_last_time () Return all messages since the given timestamp. get_metadata () Return metadata about this session. query ( text ) Run a single query against the Fixie API and return the response. run ( text ) Run a query against the Fixie API, returning a generator that yields messages. Agent Provides an interface to the Fixie GraphQL Agent API. Parameters: Name Type Description Default client FixieClient The FixieClient instance to use. required agent_id str The Agent ID, e.g., \"fixie/calc\", or handle, e.g., \"dice\". required agent_id : str property Return the agentId for this Agent. created : Optional [ datetime . datetime ] property Return the creation timestamp for this Agent. description : Optional [ str ] property Return the description for this Agent. func_url : Optional [ str ] property Return the func URL for this Agent. handle : str property Return the handle for this Agent. modified : Optional [ datetime . datetime ] property Return the modification timestamp for this Agent. more_info_url : Optional [ str ] property Return the more info URL for this Agent. name : Optional [ str ] property Return the name for this Agent. owner : Optional [ str ] property Return the owner of this Agent. published : Optional [ bool ] property Return the published status for this Agent. queries : Optional [ List [ str ]] property Return the queries for this Agent. query_url : Optional [ str ] property Return the query URL for this Agent. valid : bool property Return whether this Agent is valid. create_agent ( name , description , query_url = None , func_url = None , more_info_url = None , published = None ) Create a new Agent with the given parameters. delete_agent () Delete this Agent. get_metadata () Return metadata about this Agent. update_agent ( new_handle = None , name = None , description = None , query_url = None , func_url = None , more_info_url = None , published = None ) Update the Agent with the given parameters. fixie ( ctx ) Command-line interface to the Fixie platform. Console A simple console interface for Fixie. run ( initial_message = None ) Run the console application.","title":"Python Client API"},{"location":"python-client-api/#fixie-client-python-api-reference","text":"","title":"Fixie Client Python API Reference"},{"location":"python-client-api/#fixieai.client.client.FixieClient","text":"FixieClient is a client to the Fixie system. Parameters: Name Type Description Default api_key Optional [ str ] The API key for the Fixie API server. If not provided, the FIXIE_API_KEY environment variable will be used. If that is not set, the authenticated user API key will be used, or a ValueError will be raised if the user is not authenticated. None","title":"FixieClient"},{"location":"python-client-api/#fixieai.client.client.FixieClient.gqlclient","text":"Return the underlying GraphQL client used by this FixieClient.","title":"gqlclient"},{"location":"python-client-api/#fixieai.client.client.FixieClient.url","text":"Return the URL of the Fixie API server.","title":"url"},{"location":"python-client-api/#fixieai.client.client.FixieClient.clone","text":"Return a new FixieClient instance with the same configuration.","title":"clone()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.create_agent","text":"Create a new Agent. Parameters: Name Type Description Default handle str The handle for the new Agent. This must be unique across all Agents owned by this user. required name str The name of the new Agent. required description str A description of the new Agent. required query_url Optional [ str ] The URL of the new Agent's query endpoint. None func_url Optional [ str ] The URL of the new Agent's func endpoint. None more_info_url Optional [ str ] A URL with more information about the new Agent. None published Optional [ bool ] Whether the new Agent should be published. None","title":"create_agent()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.create_session","text":"Create a new Session.","title":"create_session()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.deploy_agent","text":"Deploys an agent implementation.","title":"deploy_agent()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.get_agent","text":"Return an existing Agent object.","title":"get_agent()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.get_agents","text":"Return metadata about all running Fixie Agents. The keys of the returned dictionary are the Agent handles, and the values are dictionaries containing metadata about each Agent.","title":"get_agents()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.get_current_username","text":"Returns the username of the current user.","title":"get_current_username()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.get_session","text":"Return an existing Session object.","title":"get_session()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.get_sessions","text":"Return a list of all session IDs.","title":"get_sessions()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.refresh_agent","text":"Indicates that an agent's prompts should be refreshed.","title":"refresh_agent()"},{"location":"python-client-api/#fixieai.client.client.get_agents","text":"Return metadata about all Fixie Agents. The keys of the returned dictionary are Agent IDs, and the values are dictionaries containing metadata about each Agent.","title":"get_agents()"},{"location":"python-client-api/#fixieai.client.client.get_client","text":"Return the global FixieClient instance.","title":"get_client()"},{"location":"python-client-api/#fixieai.client.client.get_embeds","text":"Return a list of Embeds.","title":"get_embeds()"},{"location":"python-client-api/#fixieai.client.client.get_session","text":"Return the global Fixie Session instance.","title":"get_session()"},{"location":"python-client-api/#fixieai.client.client.query","text":"Run a query.","title":"query()"},{"location":"python-client-api/#fixieai.client.session.Session","text":"Represents a single session with the Fixie system. Parameters: Name Type Description Default client FixieClient The FixieClient instance to use. required session_id Optional [ str ] The ID of the session to use. If not provided, a new session will be created. None","title":"Session"},{"location":"python-client-api/#fixieai.client.session.Session.frontend_agent_id","text":"Return the frontend agent ID used by this Fixie client.","title":"frontend_agent_id"},{"location":"python-client-api/#fixieai.client.session.Session.session_id","text":"Return the session ID used by this Fixie client.","title":"session_id"},{"location":"python-client-api/#fixieai.client.session.Session.session_url","text":"Return the URL of the Fixie session.","title":"session_url"},{"location":"python-client-api/#fixieai.client.session.Session.add_message","text":"Add a message to this Session. Returns the added message text.","title":"add_message()"},{"location":"python-client-api/#fixieai.client.session.Session.clone","text":"Return a new Session instance with the same configuration.","title":"clone()"},{"location":"python-client-api/#fixieai.client.session.Session.delete_session","text":"Delete the current session.","title":"delete_session()"},{"location":"python-client-api/#fixieai.client.session.Session.get_embeds","text":"Return the Embeds attached to this Session.","title":"get_embeds()"},{"location":"python-client-api/#fixieai.client.session.Session.get_messages","text":"Return the messages that make up this session.","title":"get_messages()"},{"location":"python-client-api/#fixieai.client.session.Session.get_messages_since_last_time","text":"Return all messages since the given timestamp.","title":"get_messages_since_last_time()"},{"location":"python-client-api/#fixieai.client.session.Session.get_metadata","text":"Return metadata about this session.","title":"get_metadata()"},{"location":"python-client-api/#fixieai.client.session.Session.query","text":"Run a single query against the Fixie API and return the response.","title":"query()"},{"location":"python-client-api/#fixieai.client.session.Session.run","text":"Run a query against the Fixie API, returning a generator that yields messages.","title":"run()"},{"location":"python-client-api/#fixieai.client.agent.Agent","text":"Provides an interface to the Fixie GraphQL Agent API. Parameters: Name Type Description Default client FixieClient The FixieClient instance to use. required agent_id str The Agent ID, e.g., \"fixie/calc\", or handle, e.g., \"dice\". required","title":"Agent"},{"location":"python-client-api/#fixieai.client.agent.Agent.agent_id","text":"Return the agentId for this Agent.","title":"agent_id"},{"location":"python-client-api/#fixieai.client.agent.Agent.created","text":"Return the creation timestamp for this Agent.","title":"created"},{"location":"python-client-api/#fixieai.client.agent.Agent.description","text":"Return the description for this Agent.","title":"description"},{"location":"python-client-api/#fixieai.client.agent.Agent.func_url","text":"Return the func URL for this Agent.","title":"func_url"},{"location":"python-client-api/#fixieai.client.agent.Agent.handle","text":"Return the handle for this Agent.","title":"handle"},{"location":"python-client-api/#fixieai.client.agent.Agent.modified","text":"Return the modification timestamp for this Agent.","title":"modified"},{"location":"python-client-api/#fixieai.client.agent.Agent.more_info_url","text":"Return the more info URL for this Agent.","title":"more_info_url"},{"location":"python-client-api/#fixieai.client.agent.Agent.name","text":"Return the name for this Agent.","title":"name"},{"location":"python-client-api/#fixieai.client.agent.Agent.owner","text":"Return the owner of this Agent.","title":"owner"},{"location":"python-client-api/#fixieai.client.agent.Agent.published","text":"Return the published status for this Agent.","title":"published"},{"location":"python-client-api/#fixieai.client.agent.Agent.queries","text":"Return the queries for this Agent.","title":"queries"},{"location":"python-client-api/#fixieai.client.agent.Agent.query_url","text":"Return the query URL for this Agent.","title":"query_url"},{"location":"python-client-api/#fixieai.client.agent.Agent.valid","text":"Return whether this Agent is valid.","title":"valid"},{"location":"python-client-api/#fixieai.client.agent.Agent.create_agent","text":"Create a new Agent with the given parameters.","title":"create_agent()"},{"location":"python-client-api/#fixieai.client.agent.Agent.delete_agent","text":"Delete this Agent.","title":"delete_agent()"},{"location":"python-client-api/#fixieai.client.agent.Agent.get_metadata","text":"Return metadata about this Agent.","title":"get_metadata()"},{"location":"python-client-api/#fixieai.client.agent.Agent.update_agent","text":"Update the Agent with the given parameters.","title":"update_agent()"},{"location":"python-client-api/#fixieai.cli.cli.fixie","text":"Command-line interface to the Fixie platform.","title":"fixie()"},{"location":"python-client-api/#fixieai.cli.session.console.Console","text":"A simple console interface for Fixie.","title":"Console"},{"location":"python-client-api/#fixieai.cli.session.console.Console.run","text":"Run the console application.","title":"run()"}]}